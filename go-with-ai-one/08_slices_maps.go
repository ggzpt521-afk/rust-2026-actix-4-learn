// ============================================================================
// 08_slices_maps.go - 切片与映射
// ============================================================================
// 运行: go run 08_slices_maps.go
//
// 【本文件学习目标】
// 1. 理解数组和切片的区别
// 2. 掌握切片的底层原理和内存布局
// 3. 学会使用 append、copy 等切片操作
// 4. 理解 map 的使用方法和注意事项
// 5. 掌握切片和 map 的常见陷阱
// 6. 了解 Go 1.21+ slices 包的新功能
//
// 【数组 vs 切片】
// | 特性       | 数组           | 切片                |
// |------------|----------------|---------------------|
// | 长度       | 固定，编译时确定 | 可变，运行时增长    |
// | 类型       | [n]T           | []T                 |
// | 传递方式   | 值传递（复制）  | 引用传递（共享底层）|
// | 比较       | 可以用 ==      | 不能用 ==           |
// | 使用频率   | 较少           | 非常常用            |
//
// 【切片内部结构】
// type slice struct {
//     array unsafe.Pointer  // 指向底层数组的指针
//     len   int             // 切片长度
//     cap   int             // 切片容量
// }
// ============================================================================

package main

import (
	"fmt"
	"slices" // Go 1.21+ 切片操作包
	"sort"   // 排序包
)

func main() {
	fmt.Println("=== Go 切片与映射 ===\n")

	// ========================================================================
	// 【数组基础】
	// ========================================================================
	// 数组是固定长度的同类型元素序列
	//
	// 【特点】
	// - 长度是类型的一部分：[3]int 和 [5]int 是不同类型
	// - 值类型：赋值和传参会复制整个数组
	// - 编译时确定大小
	//
	// 【声明方式】
	// var arr [n]T         // 零值初始化
	// arr := [n]T{...}     // 字面量初始化
	// arr := [...]T{...}   // 编译器推断长度
	// arr := [n]T{i: v}    // 指定索引初始化
	//
	// 【注意】
	// - 数组在 Go 中使用较少，切片更常用
	// - 数组作为参数传递时会复制，大数组应传指针
	// ========================================================================
	fmt.Println("--- 数组基础（固定长度）---")

	// 零值初始化：所有元素为零值
	var arr1 [5]int // [0 0 0 0 0]

	// 字面量初始化：指定所有元素
	arr2 := [5]int{1, 2, 3, 4, 5}

	// 编译器推断长度：使用 ...
	arr3 := [...]int{1, 2, 3} // 长度为 3

	// 指定索引初始化：只设置特定位置
	arr4 := [5]int{0: 1, 4: 5} // [1 0 0 0 5]

	fmt.Printf("arr1: %v\n", arr1)
	fmt.Printf("arr2: %v\n", arr2)
	fmt.Printf("arr3: %v (len=%d)\n", arr3, len(arr3))
	fmt.Printf("arr4: %v\n", arr4)

	// 数组是值类型（赋值会完整复制）
	arrCopy := arr2       // 复制整个数组
	arrCopy[0] = 999      // 修改副本
	fmt.Printf("arr2[0]=%d, arrCopy[0]=%d (独立的副本)\n", arr2[0], arrCopy[0])
	// arr2 不受影响

	// ========================================================================
	// 【切片基础】
	// ========================================================================
	// 切片是对底层数组的动态窗口/视图
	//
	// 【三个属性】
	// - 指针(ptr)：指向底层数组的某个位置
	// - 长度(len)：切片包含的元素数量
	// - 容量(cap)：从切片起始到底层数组末尾的元素数量
	//
	// 【内存布局】
	// 底层数组: [a b c d e f g h]
	//              ↑     ↑
	//              ptr   ptr+len-1
	// 切片:       [c d e]
	// len=3, cap=6 (从 c 到 h)
	//
	// 【创建方式】
	// 1. 从数组创建：array[low:high]
	// 2. 切片字面量：[]T{...}
	// 3. make 函数：make([]T, len, cap)
	// 4. nil 切片：var s []T
	// ========================================================================
	fmt.Println("\n--- 切片基础 ---")

	// 方式1: 从数组创建切片
	array := [5]int{10, 20, 30, 40, 50}
	slice1 := array[1:4] // 包含索引 1, 2, 3 的元素
	fmt.Printf("array: %v\n", array)
	fmt.Printf("slice1 (array[1:4]): %v\n", slice1) // [20 30 40]

	// 方式2: 切片字面量（会自动创建底层数组）
	slice2 := []int{1, 2, 3, 4, 5}
	fmt.Printf("slice2: %v\n", slice2)

	// 方式3: make 函数创建
	slice3 := make([]int, 5)     // len=5, cap=5，元素为零值
	slice4 := make([]int, 3, 10) // len=3, cap=10
	fmt.Printf("slice3: %v (len=%d, cap=%d)\n", slice3, len(slice3), cap(slice3))
	fmt.Printf("slice4: %v (len=%d, cap=%d)\n", slice4, len(slice4), cap(slice4))

	// 方式4: nil 切片
	var slice5 []int // 声明但不初始化
	fmt.Printf("nil 切片: %v, len=%d, cap=%d, isNil=%v\n",
		slice5, len(slice5), cap(slice5), slice5 == nil)
	// nil 切片可以安全地使用 len、cap、append

	// ========================================================================
	// 【切片操作】
	// ========================================================================
	// 切片表达式：s[low:high] 或 s[low:high:max]
	//
	// 【基本语法】s[low:high]
	// - 创建新切片，包含索引 [low, high) 的元素
	// - 省略 low 默认为 0
	// - 省略 high 默认为 len(s)
	// - 新切片的 len = high - low
	// - 新切片的 cap = cap(s) - low
	//
	// 【三索引语法】s[low:high:max]（Go 1.2+）
	// - max 限制新切片的容量
	// - 新切片的 cap = max - low
	// - 用于防止切片共享底层数组时的意外覆盖
	// ========================================================================
	fmt.Println("\n--- 切片操作 ---")

	s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	fmt.Printf("原始切片: %v\n", s)

	// 基本切片语法
	fmt.Printf("s[2:5]: %v\n", s[2:5]) // [2 3 4]
	fmt.Printf("s[:5]: %v\n", s[:5])   // [0 1 2 3 4] 等价于 s[0:5]
	fmt.Printf("s[5:]: %v\n", s[5:])   // [5 6 7 8 9] 等价于 s[5:len(s)]
	fmt.Printf("s[:]: %v\n", s[:])     // 完整切片（浅拷贝）

	// 三索引切片 [low:high:max] - 限制容量
	// 常用于避免 append 时覆盖原数组的其他元素
	limited := s[2:5:7] // len=3, cap=5 (7-2=5)
	fmt.Printf("s[2:5:7]: %v (len=%d, cap=%d)\n", limited, len(limited), cap(limited))

	// ========================================================================
	// 【append 操作】
	// ========================================================================
	// append 是切片最常用的内置函数
	//
	// 【语法】
	// newSlice = append(slice, elem1, elem2, ...)
	// newSlice = append(slice, anotherSlice...)
	//
	// 【原理】
	// - 如果容量足够：直接在底层数组追加，返回新的 slice header
	// - 如果容量不足：分配新的更大的底层数组，复制数据，再追加
	//
	// 【扩容策略】（Go 1.18+）
	// - len < 256：容量翻倍
	// - len >= 256：增长约 1.25 倍
	//
	// 【重要】
	// - append 可能返回新的切片，必须用返回值
	// - slice = append(slice, elem) // 正确
	// - append(slice, elem)         // 错误！结果丢失
	// ========================================================================
	fmt.Println("\n--- append 操作 ---")

	a := []int{1, 2, 3}
	fmt.Printf("原始: %v (len=%d, cap=%d)\n", a, len(a), cap(a))

	// 追加单个元素
	a = append(a, 4)
	fmt.Printf("追加1个: %v (len=%d, cap=%d)\n", a, len(a), cap(a))

	// 追加多个元素
	a = append(a, 5, 6, 7)
	fmt.Printf("追加多个: %v (len=%d, cap=%d)\n", a, len(a), cap(a))

	// 追加另一个切片（使用 ... 展开）
	b := []int{8, 9, 10}
	a = append(a, b...) // 必须使用 ... 展开
	fmt.Printf("追加切片: %v (len=%d, cap=%d)\n", a, len(a), cap(a))

	// ========================================================================
	// 【copy 操作】
	// ========================================================================
	// copy 将元素从源切片复制到目标切片
	//
	// 【语法】
	// n := copy(dst, src) // 返回实际复制的元素数量
	//
	// 【规则】
	// - 复制数量 = min(len(dst), len(src))
	// - 不会自动扩展 dst
	// - dst 和 src 可以重叠（安全）
	//
	// 【用途】
	// - 创建切片的独立副本
	// - 避免底层数组共享的副作用
	// ========================================================================
	fmt.Println("\n--- copy 操作 ---")

	src := []int{1, 2, 3, 4, 5}
	dst := make([]int, 3) // 只有 3 个位置
	n := copy(dst, src)   // 只复制 3 个元素
	fmt.Printf("src: %v\n", src)
	fmt.Printf("dst: %v (复制了 %d 个元素)\n", dst, n)

	// 完整复制（创建独立副本）
	fullCopy := make([]int, len(src))
	copy(fullCopy, src)
	fullCopy[0] = 999 // 修改副本
	fmt.Printf("src[0]=%d, fullCopy[0]=%d (独立副本)\n", src[0], fullCopy[0])
	// src 不受影响

	// ========================================================================
	// 【切片删除元素】
	// ========================================================================
	// Go 没有内置的删除函数，需要用 append 实现
	//
	// 【删除索引 i 的元素】
	// s = append(s[:i], s[i+1:]...)
	//
	// 【原理】
	// s[:i] 保留索引 i 之前的元素
	// s[i+1:] 保留索引 i 之后的元素
	// append 将它们连接起来
	//
	// 【注意】
	// - 这会修改原切片的底层数组
	// - 时间复杂度 O(n)
	// - 如果不需要保持顺序，可以用最后元素替换的方式 O(1)
	// ========================================================================
	fmt.Println("\n--- 切片删除元素 ---")

	nums := []int{0, 1, 2, 3, 4, 5}
	fmt.Printf("原始: %v\n", nums)

	// 删除索引2的元素（保持顺序）
	idx := 2
	nums = append(nums[:idx], nums[idx+1:]...)
	fmt.Printf("删除索引2后: %v\n", nums) // [0 1 3 4 5]

	// 删除首尾元素
	nums = nums[1:]           // 删除第一个
	nums = nums[:len(nums)-1] // 删除最后一个
	fmt.Printf("删除首尾后: %v\n", nums) // [1 3 4]

	// ========================================================================
	// 【切片底层原理】
	// ========================================================================
	// 理解切片共享底层数组是避免 bug 的关键
	//
	// 【共享底层数组】
	// - 从同一数组创建的切片共享数据
	// - 修改一个切片可能影响其他切片
	// - append 扩容后会使用新的底层数组，不再共享
	//
	// 【常见陷阱】
	// 1. 以为切片是独立的，修改后影响了原数据
	// 2. 以为切片还共享，append 后实际已经分离
	// 3. 在循环中保存切片变量，都指向同一个底层数组
	// ========================================================================
	fmt.Println("\n--- 切片底层原理 ---")

	original := []int{1, 2, 3, 4, 5}
	subSlice := original[1:4] // 共享底层数组

	fmt.Printf("original: %v\n", original)
	fmt.Printf("subSlice: %v\n", subSlice)

	// 修改 subSlice 会影响 original（共享底层数组）
	subSlice[0] = 999
	fmt.Printf("修改 subSlice[0]=999 后:\n")
	fmt.Printf("  original: %v\n", original) // [1 999 3 4 5]
	fmt.Printf("  subSlice: %v\n", subSlice) // [999 3 4]

	// ========================================================================
	// 【切片排序】
	// ========================================================================
	// sort 包提供了切片排序功能
	//
	// 【基本排序】
	// sort.Ints([]int)       - 整数升序
	// sort.Strings([]string) - 字符串升序
	// sort.Float64s([]float64) - 浮点数升序
	//
	// 【自定义排序】
	// sort.Slice(slice, less func(i, j int) bool)
	// sort.SliceStable(slice, less) // 稳定排序
	//
	// 【注意】
	// - 排序是原地修改（in-place）
	// - 如果需要保留原切片，先复制
	// ========================================================================
	fmt.Println("\n--- 切片排序 ---")

	unsorted := []int{5, 2, 8, 1, 9, 3}
	fmt.Printf("排序前: %v\n", unsorted)
	sort.Ints(unsorted) // 原地排序
	fmt.Printf("排序后: %v\n", unsorted)

	// 字符串排序
	words := []string{"banana", "apple", "cherry"}
	sort.Strings(words)
	fmt.Printf("字符串排序: %v\n", words)

	// 自定义排序：使用 sort.Slice
	type Person struct {
		Name string
		Age  int
	}
	people := []Person{
		{"Alice", 30},
		{"Bob", 25},
		{"Charlie", 35},
	}
	// 按年龄排序
	sort.Slice(people, func(i, j int) bool {
		return people[i].Age < people[j].Age // 升序
	})
	fmt.Printf("按年龄排序: %v\n", people)

	// ========================================================================
	// 【slices 包（Go 1.21+）】
	// ========================================================================
	// Go 1.21 引入了 slices 包，提供泛型切片操作
	//
	// 【常用函数】
	// | 函数            | 作用                        |
	// |-----------------|----------------------------|
	// | slices.Clone    | 复制切片                   |
	// | slices.Sort     | 排序切片                   |
	// | slices.Contains | 检查是否包含元素           |
	// | slices.Index    | 查找元素索引               |
	// | slices.Reverse  | 反转切片                   |
	// | slices.Equal    | 比较两个切片是否相等       |
	// | slices.Delete   | 删除元素                   |
	// | slices.Insert   | 插入元素                   |
	//
	// 【优点】
	// - 泛型支持，类型安全
	// - 比手写代码更简洁
	// - 经过优化，性能好
	// ========================================================================
	fmt.Println("\n--- slices 包 (Go 1.21+) ---")

	numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}
	fmt.Printf("原始: %v\n", numbers)

	// Clone：创建独立副本
	sorted := slices.Clone(numbers)
	slices.Sort(sorted) // 原地排序
	fmt.Printf("排序: %v\n", sorted)

	// Contains：检查是否包含元素
	fmt.Printf("包含 5: %v\n", slices.Contains(numbers, 5)) // true
	fmt.Printf("包含 7: %v\n", slices.Contains(numbers, 7)) // false

	// Index：查找元素索引
	fmt.Printf("5 的索引: %d\n", slices.Index(numbers, 5)) // 4

	// Reverse：反转切片
	reversed := slices.Clone(numbers)
	slices.Reverse(reversed)
	fmt.Printf("反转: %v\n", reversed)

	// ========================================================================
	// 【Map 基础】
	// ========================================================================
	// Map 是键值对的无序集合，也叫字典、哈希表
	//
	// 【类型】
	// map[KeyType]ValueType
	//
	// 【键类型要求】
	// - 必须是可比较的类型（可以用 == 比较）
	// - 可以：整数、字符串、布尔、指针、数组、结构体（如果所有字段可比较）
	// - 不可以：切片、map、函数
	//
	// 【创建方式】
	// 1. make：m := make(map[K]V)
	// 2. 字面量：m := map[K]V{...}
	// 3. nil map：var m map[K]V（只读，不能写入）
	//
	// 【内部实现】
	// - 哈希表实现
	// - 平均 O(1) 的读写性能
	// - 遍历顺序不确定（随机化）
	// ========================================================================
	fmt.Println("\n\n--- Map 基础 ---")

	// 方式1: make 创建
	ages := make(map[string]int) // 空 map
	ages["Alice"] = 25           // 添加键值对
	ages["Bob"] = 30
	fmt.Printf("ages: %v\n", ages)

	// 方式2: 字面量创建
	scores := map[string]int{
		"Math":    95,
		"English": 88,
		"Science": 92,
	}
	fmt.Printf("scores: %v\n", scores)

	// 方式3: nil map（只读，写入会 panic）
	var nilMap map[string]int
	fmt.Printf("nil map: %v, isNil=%v\n", nilMap, nilMap == nil)
	// nilMap["key"] = 1 // panic: assignment to entry in nil map

	// ========================================================================
	// 【Map 操作】
	// ========================================================================
	// CRUD 操作：创建、读取、更新、删除
	//
	// 【读取】
	// value := m[key]      // 不存在返回零值
	// value, ok := m[key]  // ok 表示键是否存在
	//
	// 【写入/更新】
	// m[key] = value
	//
	// 【删除】
	// delete(m, key)  // key 不存在也不会 panic
	//
	// 【长度】
	// len(m)  // 返回键值对数量
	//
	// 【注意】
	// - 读取不存在的键返回零值，无法区分"不存在"和"值为零值"
	// - 使用 comma ok 模式检查键是否存在
	// ========================================================================
	fmt.Println("\n--- Map 操作 ---")

	m := map[string]int{"a": 1, "b": 2, "c": 3}
	fmt.Printf("原始 map: %v\n", m)

	// 读取（不存在返回零值）
	fmt.Printf("m[\"a\"] = %d\n", m["a"])     // 1
	fmt.Printf("m[\"x\"] = %d (不存在)\n", m["x"]) // 0（零值）

	// 检查键是否存在（comma ok 模式）
	if val, ok := m["a"]; ok {
		fmt.Printf("键 'a' 存在，值为 %d\n", val)
	}
	if _, ok := m["x"]; !ok {
		fmt.Println("键 'x' 不存在")
	}

	// 添加/修改
	m["d"] = 4   // 添加新键
	m["a"] = 100 // 修改已有键
	fmt.Printf("修改后: %v\n", m)

	// 删除
	delete(m, "b") // 删除键 "b"
	fmt.Printf("删除 'b' 后: %v\n", m)

	// 长度
	fmt.Printf("map 长度: %d\n", len(m))

	// ========================================================================
	// 【遍历 Map】
	// ========================================================================
	// 使用 for...range 遍历 map
	//
	// 【语法】
	// for key, value := range m { }
	// for key := range m { }        // 只需要键
	//
	// 【重要：遍历顺序不确定】
	// - Map 遍历顺序是随机的（故意设计）
	// - 每次运行顺序可能不同
	// - 如果需要有序遍历，先获取所有键排序
	// ========================================================================
	fmt.Println("\n--- 遍历 Map ---")

	colors := map[string]string{
		"red":   "#FF0000",
		"green": "#00FF00",
		"blue":  "#0000FF",
	}

	// 遍历键值对
	fmt.Println("遍历键值对:")
	for key, value := range colors {
		fmt.Printf("  %s: %s\n", key, value)
	}

	// 只遍历键
	fmt.Print("只遍历键: ")
	for key := range colors {
		fmt.Printf("%s ", key)
	}
	fmt.Println()

	// ========================================================================
	// 【Map 作为集合（Set）】
	// ========================================================================
	// Go 没有内置 Set 类型，通常用 map[T]struct{} 实现
	//
	// 【为什么用 struct{} 而不是 bool？】
	// - struct{} 大小为 0，不占用额外内存
	// - bool 虽然逻辑上只需要 1 位，但实际占 1 字节
	//
	// 【Set 操作】
	// - 添加：set[elem] = struct{}{}
	// - 删除：delete(set, elem)
	// - 检查：_, exists := set[elem]
	// - 大小：len(set)
	// ========================================================================
	fmt.Println("\n--- Map 作为集合 (Set) ---")

	// 创建 Set
	set := make(map[string]struct{})
	set["apple"] = struct{}{} // 添加元素
	set["banana"] = struct{}{}
	set["cherry"] = struct{}{}

	// 检查成员
	if _, exists := set["apple"]; exists {
		fmt.Println("apple 在集合中")
	}

	// 删除成员
	delete(set, "banana")

	// 集合大小
	fmt.Printf("集合大小: %d\n", len(set))

	// ========================================================================
	// 【嵌套 Map】
	// ========================================================================
	// Map 的值可以是另一个 map，形成嵌套结构
	//
	// 【注意】
	// - 使用前必须初始化内层 map
	// - 直接访问未初始化的内层 map 会 panic
	//
	// 【初始化模式】
	// if m[key] == nil {
	//     m[key] = make(map[K2]V2)
	// }
	// m[key][key2] = value
	// ========================================================================
	fmt.Println("\n--- 嵌套 Map ---")

	// 二维 map
	matrix := map[string]map[string]int{}

	// 需要先初始化内层 map！
	if matrix["row1"] == nil {
		matrix["row1"] = make(map[string]int)
	}
	matrix["row1"]["col1"] = 1
	matrix["row1"]["col2"] = 2

	fmt.Printf("matrix: %v\n", matrix)
	fmt.Printf("matrix[row1][col1] = %d\n", matrix["row1"]["col1"])

	// ========================================================================
	// 【Map 与并发】
	// ========================================================================
	// 普通 map 不是并发安全的！
	//
	// 【问题】
	// - 多个 goroutine 同时读写会导致 fatal error
	// - 运行时会检测并发读写并 panic
	//
	// 【解决方案】
	// 1. sync.Mutex 或 sync.RWMutex 加锁
	// 2. sync.Map（并发安全的 map）
	// 3. 使用 channel 串行化访问
	//
	// 【sync.Map 适用场景】
	// - 键值对只写入一次但读取多次
	// - 多个 goroutine 读写不同的键
	// ========================================================================
	fmt.Println("\n--- Map 与并发（注意）---")
	fmt.Println("普通 map 不是并发安全的！")
	fmt.Println("并发场景请使用 sync.Map 或加锁")

	// ========================================================================
	// 【二维切片】
	// ========================================================================
	// Go 没有真正的多维数组/切片，用切片的切片实现
	//
	// 【创建方式】
	// 1. 先创建外层切片
	// 2. 再逐个创建内层切片
	//
	// 【注意】
	// - 内层切片长度可以不同（锯齿数组）
	// - 必须显式初始化每个内层切片
	// ========================================================================
	fmt.Println("\n--- 二维切片 ---")

	// 创建 3x4 的二维切片
	rows, cols := 3, 4
	grid := make([][]int, rows) // 创建外层切片
	for i := range grid {
		grid[i] = make([]int, cols) // 创建每个内层切片
	}

	// 填充数据
	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			grid[i][j] = i*cols + j
		}
	}

	// 打印
	fmt.Println("二维切片:")
	for _, row := range grid {
		fmt.Printf("  %v\n", row)
	}
}
