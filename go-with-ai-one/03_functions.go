// ============================================================================
// 03_functions.go - 函数
// ============================================================================
// 运行: go run 03_functions.go
//
// 【本文件学习目标】
// 1. 掌握 Go 函数的声明和调用方式
// 2. 理解多返回值和命名返回值
// 3. 学会使用可变参数
// 4. 掌握匿名函数和闭包
// 5. 理解高阶函数和函数式编程
// 6. 了解 defer 的执行机制
//
// 【Go 函数特点】
// - 函数是一等公民（First-class Citizen）
// - 支持多返回值
// - 支持命名返回值
// - 支持可变参数
// - 支持闭包
// - 不支持函数重载（同名不同参数）
// - 不支持默认参数值
// ============================================================================

package main

import (
	"fmt"
	"strings"
)

func main() {
	fmt.Println("=== Go 函数 ===\n")

	// ========================================================================
	// 【基本函数调用】
	// ========================================================================
	// 函数调用的基本语法：函数名(参数列表)
	//
	// 【原理】
	// - 函数调用时，参数按值传递（Pass by Value）
	// - 即使是切片、map 也是按值传递，但它们包含指向底层数据的指针
	// - 结构体按值传递时会完整复制
	//
	// 【注意】
	// - Go 中函数名首字母大写表示可导出（Public）
	// - 函数名首字母小写表示包内私有（Private）
	// ========================================================================
	fmt.Println("--- 基本函数 ---")
	greet("Gopher")        // 调用无返回值函数
	result := add(3, 5)    // 调用有返回值函数，接收返回值
	fmt.Printf("add(3, 5) = %d\n", result)

	// ========================================================================
	// 【多返回值】
	// ========================================================================
	// Go 函数可以返回多个值，这是 Go 的重要特性
	//
	// 【原理】
	// - 多返回值在底层通过栈传递
	// - 编译器会为每个返回值分配存储空间
	//
	// 【典型用法】
	// 1. 返回结果和错误：value, err := doSomething()
	// 2. 返回多个相关值：quotient, remainder := divide(17, 5)
	// 3. 返回修改后的值和状态：newValue, ok := transform(value)
	//
	// 【注意】
	// - 必须接收所有返回值，或使用 _ 忽略不需要的值
	// - 多返回值不是元组，不能作为单一值传递
	// ========================================================================
	fmt.Println("\n--- 多返回值 ---")
	quotient, remainder := divide(17, 5) // 接收两个返回值
	fmt.Printf("17 / 5 = %d 余 %d\n", quotient, remainder)

	// 使用空白标识符 _ 忽略不需要的返回值
	q, _ := divide(10, 3) // 只要商，忽略余数
	fmt.Printf("10 / 3 = %d (余数被忽略)\n", q)

	// ========================================================================
	// 【命名返回值】
	// ========================================================================
	// 可以在函数签名中为返回值命名
	//
	// 【原理】
	// - 命名返回值相当于在函数开头声明了变量
	// - 这些变量会被初始化为零值
	// - return 语句可以省略返回值（裸返回）
	//
	// 【优点】
	// - 文档作用：清晰说明每个返回值的含义
	// - 简化代码：可以使用裸返回
	// - defer 中可以修改返回值
	//
	// 【注意】
	// - 命名返回值在长函数中可能降低可读性
	// - 短函数推荐使用命名返回值
	// - 长函数推荐显式 return
	// ========================================================================
	fmt.Println("\n--- 命名返回值 ---")
	area, perimeter := rectangle(5, 3)
	fmt.Printf("矩形(5x3): 面积=%d, 周长=%d\n", area, perimeter)

	// ========================================================================
	// 【可变参数】
	// ========================================================================
	// 函数可以接受不定数量的参数
	//
	// 【语法】
	// func 函数名(参数名 ...类型) { }
	// - ... 表示可变参数
	// - 可变参数在函数内部是一个切片
	//
	// 【注意】
	// - 可变参数必须是最后一个参数
	// - 可以传递 0 个或多个值
	// - 用 切片... 展开切片作为可变参数
	// ========================================================================
	fmt.Println("\n--- 可变参数 ---")
	fmt.Printf("sum() = %d\n", sum())                // 0 个参数
	fmt.Printf("sum(1) = %d\n", sum(1))              // 1 个参数
	fmt.Printf("sum(1,2,3,4,5) = %d\n", sum(1, 2, 3, 4, 5)) // 5 个参数

	// 展开切片作为可变参数
	nums := []int{10, 20, 30}
	fmt.Printf("sum(nums...) = %d\n", sum(nums...)) // 使用 ... 展开切片

	// ========================================================================
	// 【函数作为值（函数是一等公民）】
	// ========================================================================
	// 在 Go 中，函数可以：
	// - 赋值给变量
	// - 作为参数传递给其他函数
	// - 作为返回值返回
	//
	// 【函数类型】
	// func(参数类型) 返回类型
	// 例如：func(int, int) int 表示接受两个 int 返回一个 int 的函数
	//
	// 【原理】
	// - 函数在内存中有一个地址
	// - 函数类型变量存储的是函数的地址
	// - 通过变量调用函数时，Go 会跳转到该地址执行
	// ========================================================================
	fmt.Println("\n--- 函数作为值 ---")

	// 声明函数类型变量
	var mathOp func(int, int) int // 声明一个函数类型变量
	mathOp = add                   // 将 add 函数赋值给变量
	fmt.Printf("mathOp(10, 20) = %d\n", mathOp(10, 20)) // 通过变量调用

	mathOp = multiply              // 换成 multiply 函数
	fmt.Printf("mathOp(10, 20) = %d\n", mathOp(10, 20)) // 调用 multiply

	// ========================================================================
	// 【匿名函数】
	// ========================================================================
	// 没有名字的函数，也叫 lambda 表达式或函数字面量
	//
	// 【语法】
	// func(参数列表) 返回类型 { 函数体 }
	//
	// 【用途】
	// - 一次性使用的简单逻辑
	// - 作为回调函数
	// - 创建闭包
	//
	// 【注意】
	// - 匿名函数可以立即调用：func() { }()
	// - 也可以赋值给变量后调用
	// ========================================================================
	fmt.Println("\n--- 匿名函数 ---")

	// 定义并立即调用（IIFE: Immediately Invoked Function Expression）
	func() {
		fmt.Println("这是一个匿名函数")
	}() // 注意最后的 ()，表示立即调用

	// 带参数的匿名函数
	func(name string) {
		fmt.Printf("Hello, %s!\n", name)
	}("Anonymous") // 传递参数 "Anonymous"

	// 赋值给变量
	square := func(n int) int { // square 是一个函数类型变量
		return n * n
	}
	fmt.Printf("square(7) = %d\n", square(7))

	// ========================================================================
	// 【闭包（Closure）】
	// ========================================================================
	// 闭包是一个函数值，它引用了其函数体外部的变量
	//
	// 【原理】
	// - 闭包"捕获"了外部变量
	// - 被捕获的变量与闭包共享同一份数据
	// - 即使外部函数返回，闭包仍然可以访问这些变量
	// - 这些变量被"逃逸"到堆上，由 GC 管理
	//
	// 【用途】
	// - 创建有状态的函数（如计数器）
	// - 实现工厂模式
	// - 数据封装（模拟私有变量）
	//
	// 【注意】
	// - 闭包会延长变量的生命周期
	// - 循环中创建闭包要注意变量捕获问题
	// ========================================================================
	fmt.Println("\n--- 闭包 ---")

	// 计数器闭包示例
	counter := makeCounter() // makeCounter 返回一个闭包
	fmt.Printf("counter() = %d\n", counter()) // 1
	fmt.Printf("counter() = %d\n", counter()) // 2
	fmt.Printf("counter() = %d\n", counter()) // 3
	// counter 持有 count 变量的引用，每次调用都会修改它

	// 创建另一个独立的计数器
	counter2 := makeCounter()
	fmt.Printf("counter2() = %d\n", counter2()) // 1（独立的 count）

	// 带参数的闭包
	adder := makeAdder(10) // 创建一个"加 10"的函数
	fmt.Printf("adder(5) = %d\n", adder(5))   // 10 + 5 = 15
	fmt.Printf("adder(3) = %d\n", adder(3))   // 10 + 3 = 13

	// ========================================================================
	// 【高阶函数（Higher-Order Functions）】
	// ========================================================================
	// 高阶函数是接受函数作为参数或返回函数的函数
	//
	// 【常见模式】
	// - map：对每个元素应用函数
	// - filter：过滤符合条件的元素
	// - reduce：将元素归约为单一值
	//
	// 【函数式编程优点】
	// - 代码更简洁、声明式
	// - 易于组合和重用
	// - 减少副作用
	//
	// 【注意】
	// - Go 标准库没有泛型版本的 map/filter/reduce
	// - 通常需要自己实现或使用第三方库
	// - Go 1.21+ 的 slices 包提供了一些类似功能
	// ========================================================================
	fmt.Println("\n--- 高阶函数 ---")

	// 函数作为参数：map 操作
	numbers := []int{1, 2, 3, 4, 5}
	doubled := mapInts(numbers, func(n int) int {
		return n * 2 // 每个元素乘以 2
	})
	fmt.Printf("原始: %v\n", numbers)
	fmt.Printf("翻倍: %v\n", doubled)

	// filter 操作：过滤出偶数
	evens := filterInts(numbers, func(n int) bool {
		return n%2 == 0 // 判断是否为偶数
	})
	fmt.Printf("偶数: %v\n", evens)

	// reduce 操作：求和
	total := reduceInts(numbers, 0, func(acc, n int) int {
		return acc + n // 累加
	})
	fmt.Printf("总和: %d\n", total)

	// ========================================================================
	// 【函数返回函数（函数工厂）】
	// ========================================================================
	// 函数可以返回另一个函数，常用于创建定制化的函数
	//
	// 【用途】
	// - 工厂模式：根据参数创建不同行为的函数
	// - 柯里化（Currying）：将多参数函数转换为单参数函数链
	// - 依赖注入：将依赖封装在闭包中
	// ========================================================================
	fmt.Println("\n--- 函数返回函数 ---")

	// 函数工厂：创建不同语言的问候函数
	greetEnglish := makeGreeter("Hello")   // 创建英文问候函数
	greetChinese := makeGreeter("你好")    // 创建中文问候函数
	fmt.Println(greetEnglish("World"))     // Hello, World!
	fmt.Println(greetChinese("世界"))      // 你好, 世界!

	// ========================================================================
	// 【递归函数】
	// ========================================================================
	// 函数调用自身的编程技术
	//
	// 【原理】
	// - 每次递归调用都会在栈上创建新的栈帧
	// - 必须有终止条件（基准情况）
	// - 问题规模必须向基准情况收敛
	//
	// 【经典示例】
	// - 阶乘：n! = n × (n-1)!
	// - 斐波那契数列：F(n) = F(n-1) + F(n-2)
	// - 树的遍历
	//
	// 【注意】
	// - 递归深度过大会导致栈溢出（Stack Overflow）
	// - Go 没有尾递归优化（Tail Call Optimization）
	// - 对于深递归，考虑使用循环或增加栈大小
	// ========================================================================
	fmt.Println("\n--- 递归函数 ---")
	fmt.Printf("factorial(5) = %d\n", factorial(5))   // 5! = 120
	fmt.Printf("fibonacci(10) = %d\n", fibonacci(10)) // F(10) = 55

	// ========================================================================
	// 【defer 基础】
	// ========================================================================
	// defer 语句将函数调用推迟到外层函数返回之前执行
	//
	// 【执行顺序】
	// - 多个 defer 按 LIFO（后进先出）顺序执行
	// - 类似栈：最后 defer 的最先执行
	//
	// 【参数求值】
	// - defer 语句的参数在 defer 时立即求值
	// - 不是在实际执行时求值
	//
	// 【用途】
	// - 资源清理（关闭文件、释放锁）
	// - 配合 recover 处理 panic
	// - 修改命名返回值
	//
	// 【详细说明见 04_control_flow.go】
	// ========================================================================
	fmt.Println("\n--- defer 基础 ---")
	deferDemo()

	// ========================================================================
	// 【方法值和方法表达式】
	// ========================================================================
	// 方法可以像普通函数一样作为值使用
	//
	// 【方法值】
	// - 从特定实例获取：instance.Method
	// - 绑定了接收者，可以直接调用
	//
	// 【方法表达式】
	// - 从类型获取：Type.Method
	// - 第一个参数是接收者
	//
	// 【详细说明见 06_structs.go】
	// ========================================================================
	fmt.Println("\n--- 方法值 ---")
	calc := Calculator{value: 10}
	addMethod := calc.Add // 方法值：绑定了 calc 实例
	fmt.Printf("calc.Add(5) via method value = %d\n", addMethod(5))
	// addMethod 相当于一个闭包，捕获了 calc
}

// ============================================================================
// 【基本函数定义】
// ============================================================================
// 语法: func 函数名(参数列表) 返回类型 { 函数体 }
//
// 【参数传递方式】
// - Go 只有值传递（Pass by Value）
// - 基本类型：复制值
// - 切片/map/channel：复制头部结构（包含指针），底层数据共享
// - 指针：复制指针值（地址）
// - 结构体：完整复制所有字段
// ============================================================================

// greet: 无返回值的函数
// 参数: name - 要问候的名字
func greet(name string) {
	fmt.Printf("Hello, %s!\n", name)
}

// add: 带返回值的函数
// 参数: a, b - 两个整数（当连续参数类型相同时可以简写）
// 返回: 两数之和
func add(a, b int) int { // a, b int 是 a int, b int 的简写
	return a + b
}

// multiply: 乘法运算
func multiply(a, b int) int {
	return a * b
}

// ============================================================================
// 【多返回值函数】
// ============================================================================
// 语法: func 函数名(参数列表) (返回类型1, 返回类型2, ...) { }
//
// 【原理】
// - 返回值通过栈传递
// - 调用者预先在栈上分配返回值空间
// ============================================================================

// divide: 整数除法，返回商和余数
// 返回: (商, 余数)
func divide(dividend, divisor int) (int, int) {
	quotient := dividend / divisor  // 整数除法，向零取整
	remainder := dividend % divisor // 取模运算
	return quotient, remainder
}

// ============================================================================
// 【命名返回值】
// ============================================================================
// 语法: func 函数名(参数) (返回值名 类型, ...) { }
//
// 【特点】
// - 返回值在函数开始时被初始化为零值
// - 可以像普通变量一样使用
// - return 可以省略返回值（裸返回）
// ============================================================================

// rectangle: 计算矩形的面积和周长
// 使用命名返回值，代码更清晰
func rectangle(width, height int) (area, perimeter int) {
	area = width * height         // 直接赋值给返回值变量
	perimeter = 2 * (width + height)
	return // 裸返回：自动返回 area 和 perimeter 的当前值
	// 等价于: return area, perimeter
}

// ============================================================================
// 【可变参数函数】
// ============================================================================
// 语法: func 函数名(参数名 ...类型) { }
//
// 【原理】
// - 可变参数在函数内部是一个切片
// - 编译器自动将多个参数包装成切片
// - 使用 slice... 可以展开切片作为可变参数
// ============================================================================

// sum: 计算任意数量整数的和
// nums 在函数内部是 []int 类型
func sum(nums ...int) int {
	total := 0
	for _, n := range nums { // 遍历切片
		total += n
	}
	return total
}

// ============================================================================
// 【闭包工厂函数】
// ============================================================================
// 返回的函数"捕获"了外部变量
//
// 【内存模型】
// - count 变量逃逸到堆上
// - 返回的闭包持有指向 count 的引用
// - count 的生命周期与闭包绑定
// ============================================================================

// makeCounter: 创建一个计数器闭包
// 每次调用返回的函数，计数器加 1
func makeCounter() func() int {
	count := 0 // 这个变量被闭包捕获，逃逸到堆上
	return func() int {
		count++ // 修改外部变量
		return count
	}
}

// makeAdder: 创建一个"加法器"闭包
// base 参数被捕获，返回的函数总是加上 base
func makeAdder(base int) func(int) int {
	return func(n int) int {
		return base + n // base 是捕获的外部变量
	}
}

// makeGreeter: 问候函数工厂
// 根据不同的问候语创建不同的问候函数
func makeGreeter(greeting string) func(string) string {
	return func(name string) string {
		return greeting + ", " + name + "!"
	}
}

// ============================================================================
// 【高阶函数：Map/Filter/Reduce】
// ============================================================================
// 函数式编程的三大基本操作
//
// 【时间复杂度】都是 O(n)
// 【空间复杂度】
// - map: O(n) 创建新切片
// - filter: O(k) k 是满足条件的元素数
// - reduce: O(1) 只需要累加器
// ============================================================================

// mapInts: 对切片中的每个元素应用函数
// f: 转换函数，将 int 转换为 int
func mapInts(slice []int, f func(int) int) []int {
	result := make([]int, len(slice)) // 预分配相同大小的切片
	for i, v := range slice {
		result[i] = f(v) // 应用转换函数
	}
	return result
}

// filterInts: 过滤满足条件的元素
// predicate: 谓词函数，返回 true 表示保留
func filterInts(slice []int, predicate func(int) bool) []int {
	var result []int // nil 切片，按需增长
	for _, v := range slice {
		if predicate(v) { // 满足条件则保留
			result = append(result, v)
		}
	}
	return result
}

// reduceInts: 将切片归约为单一值
// initial: 累加器初始值
// f: 归约函数，接受 (累加器, 当前元素) 返回新的累加器
func reduceInts(slice []int, initial int, f func(int, int) int) int {
	acc := initial // 累加器
	for _, v := range slice {
		acc = f(acc, v) // 将当前元素合并到累加器
	}
	return acc
}

// ============================================================================
// 【递归函数】
// ============================================================================
// 函数调用自身
//
// 【递归三要素】
// 1. 基准情况（终止条件）
// 2. 递归情况（问题分解）
// 3. 问题规模向基准情况收敛
// ============================================================================

// factorial: 计算阶乘
// n! = n × (n-1) × (n-2) × ... × 1
// 0! = 1, 1! = 1
func factorial(n int) int {
	if n <= 1 { // 基准情况
		return 1
	}
	return n * factorial(n-1) // 递归情况
	// factorial(5) = 5 * factorial(4)
	//              = 5 * 4 * factorial(3)
	//              = 5 * 4 * 3 * factorial(2)
	//              = 5 * 4 * 3 * 2 * factorial(1)
	//              = 5 * 4 * 3 * 2 * 1
	//              = 120
}

// fibonacci: 计算斐波那契数列第 n 项
// F(0) = 0, F(1) = 1
// F(n) = F(n-1) + F(n-2)
//
// 【注意】
// 这个实现效率很低，O(2^n) 时间复杂度
// 因为有大量重复计算
// 实际使用应该用动态规划或记忆化
func fibonacci(n int) int {
	if n <= 1 { // 基准情况：F(0)=0, F(1)=1
		return n
	}
	return fibonacci(n-1) + fibonacci(n-2) // 递归情况
}

// ============================================================================
// 【defer 演示】
// ============================================================================
// defer 语句推迟函数执行到外层函数返回时
//
// 【执行顺序】LIFO（后进先出）
// 相当于压栈，最后 defer 的最先执行
// ============================================================================
func deferDemo() {
	fmt.Println("开始")

	// defer 按 LIFO（后进先出）顺序执行
	defer fmt.Println("defer 1") // 第三个执行
	defer fmt.Println("defer 2") // 第二个执行
	defer fmt.Println("defer 3") // 第一个执行

	fmt.Println("结束")

	// 实际输出顺序:
	// 开始
	// 结束
	// defer 3
	// defer 2
	// defer 1
}

// ============================================================================
// 【方法值演示用的结构体】
// ============================================================================
// 方法是带有接收者的函数
// 详细说明见 06_structs.go
// ============================================================================

// Calculator: 简单计算器结构体
type Calculator struct {
	value int // 当前值
}

// Add: Calculator 的方法
// 接收者是值类型（c Calculator），不会修改原结构体
func (c Calculator) Add(n int) int {
	return c.value + n
}

// ============================================================================
// 【init 函数】
// ============================================================================
// init 是特殊的初始化函数：
// - 没有参数，没有返回值
// - 每个包可以有多个 init 函数
// - 在 main 函数之前自动执行
// - 同一个文件中的 init 按声明顺序执行
// - 不同文件按文件名字母序执行
//
// 【执行顺序】
// 1. 导入的包的 init 函数
// 2. 当前包的包级变量初始化
// 3. 当前包的 init 函数
// 4. main 函数
//
// 【用途】
// - 初始化无法用声明表达的变量
// - 注册功能（如数据库驱动）
// - 运行一次性的设置代码
//
// 【注意】
// - 不能显式调用 init
// - 不应该依赖 init 的执行顺序
// ============================================================================
func init() {
	// 可以用于初始化工作
	_ = strings.TrimSpace(" init ") // 示例：使用导入的包
	// 这里只是演示 init 函数存在
	// 实际项目中会做一些初始化工作
}
