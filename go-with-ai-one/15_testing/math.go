// ============================================================================
// Package testing_demo 演示 Go 单元测试
// ============================================================================
//
// 【本文件学习目标】
// 1. 理解如何编写可测试的 Go 代码
// 2. 学习函数设计的最佳实践
// 3. 掌握函数文档注释规范
//
// 【可测试代码的特点】
// - 函数功能单一、职责明确
// - 输入输出清晰，无副作用
// - 依赖可注入（便于 mock）
// - 边界情况考虑完整
//
// 【Go 文档注释规范】
// - 注释以函数名开头
// - 第一句是简短描述
// - 后续可以详细说明
// - 示例：// Add 返回两个整数的和
// ============================================================================
package testing_demo

import "errors"

// ============================================================================
// 【基本算术函数】
// ============================================================================
// 这些函数展示了最简单的可测试函数：
// - 纯函数：相同输入总是产生相同输出
// - 无副作用：不修改外部状态
// - 易于测试：只需验证输入输出
// ============================================================================

// Add 返回两个整数的和
// 【纯函数】没有副作用，相同输入总是相同输出
// 这种函数最容易测试
func Add(a, b int) int {
	return a + b
}

// Subtract 返回两个整数的差
// a - b 的结果
func Subtract(a, b int) int {
	return a - b
}

// ============================================================================
// 【带错误返回的函数】
// ============================================================================
// Go 惯用的错误处理方式：返回 (result, error)
// 测试时需要同时测试正常情况和错误情况
// ============================================================================

// Divide 返回两个整数的商
// 【错误处理】除数为 0 时返回错误
//
// 【返回值】
// - 成功：返回商和 nil
// - 失败：返回 0 和错误
//
// 【测试要点】
// 1. 正常除法
// 2. 除数为 0
// 3. 负数除法
// 4. 整数除法的截断
func Divide(a, b int) (int, error) {
	if b == 0 {
		return 0, errors.New("division by zero")
	}
	return a / b, nil
}

// ============================================================================
// 【算法函数】
// ============================================================================
// 素数判断和斐波那契数列是经典的算法练习
// 测试时需要考虑边界条件
// ============================================================================

// IsPrime 判断是否为素数
// 【算法】试除法：检查 2 到 sqrt(n) 之间是否有因子
//
// 【素数定义】
// - 大于 1 的自然数
// - 只能被 1 和自身整除
//
// 【边界条件】
// - n < 2：不是素数
// - n = 2：最小的素数
// - n = 偶数（>2）：不是素数
//
// 【测试用例设计】
// - 边界值：0, 1, 2
// - 小素数：3, 5, 7, 11, 13
// - 合数：4, 6, 8, 9, 10
// - 大素数：97, 101
func IsPrime(n int) bool {
	// 小于 2 的数不是素数
	if n < 2 {
		return false
	}
	// 检查 2 到 sqrt(n) 的因子
	// i*i <= n 等价于 i <= sqrt(n)，避免浮点运算
	for i := 2; i*i <= n; i++ {
		if n%i == 0 {
			return false // 找到因子，不是素数
		}
	}
	return true // 没有因子，是素数
}

// Fibonacci 计算斐波那契数
// 【斐波那契数列】
// F(0) = 0, F(1) = 1
// F(n) = F(n-1) + F(n-2)
//
// 【递归实现】
// 简单但效率低，时间复杂度 O(2^n)
// 适合小数值，大数值应使用迭代或记忆化
//
// 【测试用例】
// - F(0) = 0
// - F(1) = 1
// - F(2) = 1
// - F(10) = 55
// - F(20) = 6765
//
// 【基准测试注意】
// 递归实现在大 n 时很慢
// 可以用基准测试比较不同实现的性能
func Fibonacci(n int) int {
	// 基本情况
	if n <= 1 {
		return n
	}
	// 递归调用
	return Fibonacci(n-1) + Fibonacci(n-2)
}

// ============================================================================
// 【字符串处理函数】
// ============================================================================
// 字符串操作需要考虑 Unicode
// 使用 []rune 正确处理中文等多字节字符
// ============================================================================

// ReverseString 反转字符串
// 【Unicode 处理】
// - Go 字符串是 UTF-8 编码的字节序列
// - 直接按字节反转会破坏多字节字符
// - 转换为 []rune 可以正确处理 Unicode
//
// 【算法】双指针交换
// 1. 转换为 []rune
// 2. 双指针从两端向中间交换
// 3. 转回字符串
//
// 【测试用例】
// - 空字符串：""
// - 单字符："a"
// - ASCII："Hello"
// - Unicode："你好"
// - 混合："Hello你好"
//
// 【模糊测试】
// 双重反转应该等于原字符串
// ReverseString(ReverseString(s)) == s
func ReverseString(s string) string {
	runes := []rune(s) // 转换为 rune 切片，正确处理 Unicode
	// 双指针交换
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i] // Go 支持同时赋值
	}
	return string(runes) // 转回字符串
}
