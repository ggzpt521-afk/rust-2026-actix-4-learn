// ============================================================================
// 06_structs.go - 结构体与方法
// ============================================================================
// 运行: go run 06_structs.go
//
// 【本文件学习目标】
// 1. 掌握结构体的定义和初始化
// 2. 理解值接收者和指针接收者的区别
// 3. 学会使用结构体标签（Tag）
// 4. 掌握结构体嵌套和组合
// 5. 理解 Go 的构造函数模式
// 6. 学会使用 JSON 序列化
//
// 【Go 结构体特点】
// - 没有类（Class），用结构体实现面向对象
// - 没有继承，用组合（Composition）替代
// - 方法通过接收者绑定到类型
// - 字段和方法的可见性由首字母大小写决定
// ============================================================================

package main

import (
	"encoding/json" // JSON 编解码
	"fmt"
	"unsafe"
)

// ============================================================================
// 【基本结构体定义】
// ============================================================================
// 结构体是一种聚合数据类型，将多个字段组合在一起
//
// 【语法】
// type 结构体名 struct {
//     字段名 字段类型
//     ...
// }
//
// 【命名规则】
// - 结构体名首字母大写：可导出（Public）
// - 结构体名首字母小写：包内私有（Private）
// - 字段名同理
// ============================================================================

// Person: 基本结构体示例
// 所有字段都是导出的（首字母大写）
type Person struct {
	Name string // 姓名
	Age  int    // 年龄
	City string // 城市
}

// ============================================================================
// 【带标签的结构体】
// ============================================================================
// 结构体标签（Struct Tag）用于给字段添加元信息
// 常用于 JSON、数据库映射、表单验证等
//
// 【语法】
// 字段名 字段类型 `标签键:"标签值" 标签键2:"标签值2"`
//
// 【常用标签】
// - json:"name"        : JSON 字段名
// - json:"name,omitempty" : 空值时省略
// - json:"-"           : 序列化时忽略
// - db:"column_name"   : 数据库列名
// - validate:"required" : 验证规则
// ============================================================================

// User: 带 JSON 标签的结构体
type User struct {
	ID       int    `json:"id"`               // JSON 字段名为 "id"
	Username string `json:"username"`         // JSON 字段名为 "username"
	Email    string `json:"email,omitempty"`  // omitempty: 空值时省略该字段
	Password string `json:"-"`                // -: 序列化时完全忽略
}

// ============================================================================
// 【嵌套结构体】
// ============================================================================
// 结构体可以包含其他结构体作为字段
//
// 【两种方式】
// 1. 命名字段：Address Address（需要通过字段名访问）
// 2. 匿名嵌入：Address（字段直接提升，可直接访问）
//
// 【匿名嵌入的特点】
// - 嵌入类型的字段和方法会"提升"到外层结构体
// - 可以直接访问，不需要通过字段名
// - 这是 Go 实现"继承"的方式（实际是组合）
// ============================================================================

// Address: 地址结构体
type Address struct {
	Street  string // 街道
	City    string // 城市
	Country string // 国家
}

// Employee: 嵌套结构体示例
type Employee struct {
	Person   // 匿名嵌入：Person 的字段会被提升
	Address  Address // 命名字段：需要通过 Address 访问
	Salary   float64 // 薪资
	JobTitle string  // 职位
}

// ============================================================================
// 【带方法的结构体】
// ============================================================================
// 方法是绑定到特定类型的函数
//
// 【语法】
// func (接收者 类型) 方法名(参数) 返回值 { }
//
// 【接收者类型】
// - 值接收者 (r Rectangle)：方法接收结构体的副本
// - 指针接收者 (r *Rectangle)：方法接收结构体的指针
//
// 【选择建议】
// 使用指针接收者当：
// - 方法需要修改接收者
// - 接收者是大型结构体（避免复制）
// - 保持一致性（如果有指针接收者方法，所有方法都用指针）
// ============================================================================

// Rectangle: 矩形结构体，演示方法定义
type Rectangle struct {
	Width  float64 // 宽度
	Height float64 // 高度
}

// Area: 值接收者方法，计算面积
// 值接收者不会修改原结构体
func (r Rectangle) Area() float64 {
	return r.Width * r.Height
}

// Perimeter: 值接收者方法，计算周长
func (r Rectangle) Perimeter() float64 {
	return 2 * (r.Width + r.Height)
}

// Scale: 指针接收者方法，缩放矩形
// 指针接收者可以修改原结构体
func (r *Rectangle) Scale(factor float64) {
	r.Width *= factor  // 修改宽度
	r.Height *= factor // 修改高度
}

// String: 实现 fmt.Stringer 接口
// 当使用 fmt.Println 等打印时会调用此方法
func (r Rectangle) String() string {
	return fmt.Sprintf("Rectangle(%.2f x %.2f)", r.Width, r.Height)
}

// ============================================================================
// 【构造函数模式】
// ============================================================================
// Go 没有构造函数，使用工厂函数（Factory Function）代替
//
// 【命名约定】
// - NewTypeName：返回指针
// - MakeTypeName：返回值（类似 make）
//
// 【用途】
// - 初始化私有字段
// - 参数验证
// - 设置默认值
// ============================================================================

// Circle: 圆形结构体
type Circle struct {
	Radius float64
}

// NewCircle: Circle 的构造函数
// 返回指针，可以进行参数验证
func NewCircle(radius float64) *Circle {
	if radius < 0 {
		radius = 0 // 参数验证：负数半径设为 0
	}
	return &Circle{Radius: radius}
}

// Area: 计算圆的面积
func (c Circle) Area() float64 {
	return 3.14159 * c.Radius * c.Radius
}

// ============================================================================
// 【封装：私有字段】
// ============================================================================
// Go 通过首字母大小写控制可见性
//
// 【规则】
// - 大写开头：包外可见（Public）
// - 小写开头：包内私有（Private）
//
// 【封装模式】
// - 私有字段 + 公开的 Getter/Setter 方法
// ============================================================================

// Counter: 带私有字段的结构体
type Counter struct {
	count int // 小写开头，包外不可访问
}

// NewCounter: Counter 的构造函数
func NewCounter() *Counter {
	return &Counter{count: 0}
}

// Increment: 增加计数（公开方法）
func (c *Counter) Increment() {
	c.count++
}

// Value: 获取当前值（Getter 方法）
func (c *Counter) Value() int {
	return c.count
}

// ============================================================================
// 【空结构体】
// ============================================================================
// 空结构体 struct{} 不占用内存（大小为 0）
//
// 【用途】
// 1. 作为 map 的值实现 Set
// 2. 作为 channel 的信号（不传递数据）
// 3. 作为接口实现的占位符
// ============================================================================

// Empty: 空结构体示例
type Empty struct{}

func main() {
	fmt.Println("=== Go 结构体与方法 ===\n")

	// ========================================================================
	// 【创建结构体实例】
	// ========================================================================
	// Go 提供多种创建结构体的方式
	//
	// 【推荐使用字段名指定方式】
	// - 代码更清晰
	// - 不依赖字段顺序
	// - 添加新字段时不影响现有代码
	// ========================================================================
	fmt.Println("--- 创建结构体实例 ---")

	// 方式1: 字段名指定（推荐）
	p1 := Person{
		Name: "Alice",
		Age:  25,
		City: "Beijing",
	}
	fmt.Printf("方式1: %+v\n", p1) // %+v 打印字段名和值

	// 方式2: 顺序赋值（不推荐，依赖字段顺序）
	p2 := Person{"Bob", 30, "Shanghai"}
	fmt.Printf("方式2: %+v\n", p2)

	// 方式3: 使用 new（返回指针，字段为零值）
	p3 := new(Person) // 返回 *Person
	p3.Name = "Charlie"
	fmt.Printf("方式3: %+v\n", *p3)

	// 方式4: 零值结构体
	var p4 Person // 所有字段为零值
	fmt.Printf("方式4: %+v\n", p4)

	// 方式5: 取地址（常用，可以同时初始化）
	p5 := &Person{Name: "David", Age: 28} // 未指定的字段为零值
	fmt.Printf("方式5: %+v\n", *p5)

	// ========================================================================
	// 【访问和修改字段】
	// ========================================================================
	// 使用点号 . 访问字段
	// 指针类型会自动解引用
	// ========================================================================
	fmt.Println("\n--- 访问和修改字段 ---")

	person := Person{Name: "Eve", Age: 22, City: "Shenzhen"}
	fmt.Printf("Name: %s, Age: %d\n", person.Name, person.Age)

	person.Age = 23 // 修改字段
	fmt.Printf("修改后: %+v\n", person)

	// 通过指针访问（自动解引用）
	ptrPerson := &person
	ptrPerson.City = "Guangzhou" // 等价于 (*ptrPerson).City
	fmt.Printf("通过指针修改后: %+v\n", person)

	// ========================================================================
	// 【结构体比较】
	// ========================================================================
	// 如果结构体的所有字段都是可比较的，则结构体可以比较
	//
	// 【可比较类型】
	// - 基本类型（int, string, bool 等）
	// - 指针
	// - 数组（如果元素可比较）
	// - 结构体（如果所有字段可比较）
	//
	// 【不可比较类型】
	// - 切片
	// - map
	// - 函数
	// ========================================================================
	fmt.Println("\n--- 结构体比较 ---")

	a := Person{Name: "Test", Age: 20, City: "Test"}
	b := Person{Name: "Test", Age: 20, City: "Test"}
	c := Person{Name: "Test", Age: 21, City: "Test"}

	fmt.Printf("a == b: %v\n", a == b) // true，所有字段相等
	fmt.Printf("a == c: %v\n", a == c) // false，Age 不同

	// ========================================================================
	// 【匿名结构体】
	// ========================================================================
	// 不需要预先定义类型，适合一次性使用
	//
	// 【常用场景】
	// - 临时数据结构
	// - 测试用例
	// - JSON 响应包装
	// ========================================================================
	fmt.Println("\n--- 匿名结构体 ---")

	// 一次性使用的结构体
	point := struct {
		X, Y int
	}{X: 10, Y: 20}
	fmt.Printf("匿名结构体: %+v\n", point)

	// 测试用例中常用
	testCases := []struct {
		input    int
		expected int
	}{
		{1, 2},
		{2, 4},
		{3, 6},
	}
	for _, tc := range testCases {
		fmt.Printf("  input=%d, expected=%d\n", tc.input, tc.expected)
	}

	// ========================================================================
	// 【嵌套结构体】
	// ========================================================================
	// 结构体可以包含其他结构体
	//
	// 【匿名嵌入的字段提升】
	// 当使用匿名嵌入时，被嵌入类型的字段和方法会"提升"到外层
	// 可以直接通过外层结构体访问
	// ========================================================================
	fmt.Println("\n--- 嵌套结构体 ---")

	emp := Employee{
		Person:   Person{Name: "Frank", Age: 35, City: "Beijing"},
		Address:  Address{Street: "123 Main St", City: "Beijing", Country: "China"},
		Salary:   50000,
		JobTitle: "Engineer",
	}

	fmt.Printf("Employee: %+v\n", emp)

	// 访问命名字段（需要通过字段名）
	fmt.Printf("Name: %s\n", emp.Person.Name)
	fmt.Printf("Street: %s\n", emp.Address.Street)

	// 匿名嵌入可以直接访问（字段提升）
	fmt.Printf("直接访问 Name: %s\n", emp.Name) // 等价于 emp.Person.Name
	fmt.Printf("直接访问 Age: %d\n", emp.Age)   // 等价于 emp.Person.Age

	// ========================================================================
	// 【方法调用】
	// ========================================================================
	// 方法可以通过值或指针调用
	// Go 会自动进行转换
	//
	// 【自动转换】
	// rect.Scale(2)   -> (&rect).Scale(2)  // 自动取地址
	// (&rect).Area()  -> (*(&rect)).Area() // 自动解引用
	// ========================================================================
	fmt.Println("\n--- 方法 ---")

	rect := Rectangle{Width: 10, Height: 5}
	fmt.Printf("矩形: %s\n", rect)        // 调用 String() 方法
	fmt.Printf("面积: %.2f\n", rect.Area())     // 值接收者方法
	fmt.Printf("周长: %.2f\n", rect.Perimeter()) // 值接收者方法

	// 指针接收者方法
	fmt.Println("\n--- 指针接收者 ---")
	fmt.Printf("缩放前: %s\n", rect)
	rect.Scale(2) // Go 自动转换为 (&rect).Scale(2)
	fmt.Printf("缩放后: %s\n", rect)

	// ========================================================================
	// 【构造函数模式】
	// ========================================================================
	fmt.Println("\n--- 构造函数模式 ---")

	circle := NewCircle(5)
	fmt.Printf("圆: radius=%.2f, area=%.2f\n", circle.Radius, circle.Area())

	// 构造函数可以处理无效参数
	circle2 := NewCircle(-3) // 负数半径会被处理
	fmt.Printf("负半径处理: radius=%.2f\n", circle2.Radius)

	// ========================================================================
	// 【封装示例】
	// ========================================================================
	fmt.Println("\n--- 封装（私有字段）---")

	counter := NewCounter()
	counter.Increment()
	counter.Increment()
	counter.Increment()
	fmt.Printf("Counter value: %d\n", counter.Value())
	// counter.count = 100 // 编译错误：count 是私有字段

	// ========================================================================
	// 【JSON 序列化】
	// ========================================================================
	// encoding/json 包用于 JSON 编解码
	//
	// 【序列化】
	// json.Marshal(v) -> []byte, error
	// json.MarshalIndent(v, prefix, indent) -> []byte, error（格式化）
	//
	// 【反序列化】
	// json.Unmarshal(data, &v) -> error
	//
	// 【注意】
	// - 只有导出字段（大写开头）会被序列化
	// - 使用 json 标签控制序列化行为
	// ========================================================================
	fmt.Println("\n--- JSON 序列化 ---")

	user := User{
		ID:       1,
		Username: "gopher",
		Email:    "gopher@example.com",
		Password: "secret123", // json:"-"，不会序列化
	}

	// 序列化（带格式化）
	jsonData, _ := json.MarshalIndent(user, "", "  ")
	fmt.Printf("JSON 输出:\n%s\n", jsonData)
	// 注意：Password 字段被忽略了

	// 反序列化
	jsonStr := `{"id":2,"username":"newuser"}`
	var user2 User
	json.Unmarshal([]byte(jsonStr), &user2) // 注意传指针
	fmt.Printf("反序列化: %+v\n", user2)

	// ========================================================================
	// 【空结构体】
	// ========================================================================
	// struct{} 大小为 0，不占用内存
	//
	// 【用途1】作为 Set（只关心 key）
	// map[string]struct{} 比 map[string]bool 更节省内存
	//
	// 【用途2】作为信号 channel
	// chan struct{} 用于发送信号（不传递数据）
	// ========================================================================
	fmt.Println("\n--- 空结构体 ---")

	var empty Empty
	fmt.Printf("空结构体大小: %d 字节\n", unsafe.Sizeof(empty)) // 0

	// 作为 Set 使用
	set := make(map[string]struct{})
	set["apple"] = struct{}{} // 空结构体字面量
	set["banana"] = struct{}{}
	set["cherry"] = struct{}{}

	// 检查元素是否存在
	if _, exists := set["apple"]; exists {
		fmt.Println("apple 存在于 set 中")
	}

	// 作为信号 channel
	done := make(chan struct{})
	go func() {
		fmt.Println("goroutine 执行完成")
		close(done) // 关闭 channel 作为完成信号
	}()
	<-done // 等待信号

	// ========================================================================
	// 【方法值和方法表达式】
	// ========================================================================
	// 方法可以作为值使用
	//
	// 【方法值（Method Value）】
	// - 从实例获取：instance.Method
	// - 绑定了特定实例，可以直接调用
	//
	// 【方法表达式（Method Expression）】
	// - 从类型获取：Type.Method 或 (*Type).Method
	// - 第一个参数是接收者
	// ========================================================================
	fmt.Println("\n--- 方法值和方法表达式 ---")

	r := Rectangle{Width: 3, Height: 4}

	// 方法值：绑定到特定实例
	areaFunc := r.Area          // 绑定了 r
	fmt.Printf("方法值调用: %.2f\n", areaFunc()) // 不需要传接收者

	// 方法表达式：需要显式传递接收者
	areaExpr := Rectangle.Area     // 类型的方法
	fmt.Printf("方法表达式调用: %.2f\n", areaExpr(r)) // 需要传接收者

	// 指针方法表达式
	scaleExpr := (*Rectangle).Scale
	scaleExpr(&r, 0.5) // 传递指针和参数
	fmt.Printf("指针方法表达式调用后: %s\n", r)
}
