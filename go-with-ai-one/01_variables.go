// ============================================================================
// 01_variables.go - 变量与常量
// ============================================================================
// 运行: go run 01_variables.go
//
// 【本文件学习目标】
// 1. 掌握 Go 语言的 5 种变量声明方式
// 2. 理解零值（Zero Value）机制
// 3. 学会使用常量和 iota 枚举
// 4. 理解变量作用域和遮蔽（Shadowing）
// 5. 掌握空白标识符 _ 的用法
// ============================================================================

package main // 每个 Go 程序必须属于一个包，main 包是程序入口点

import "fmt" // 导入格式化 I/O 包，用于打印输出

// ============================================================================
// 【包级别常量】
// ============================================================================
// 常量使用 const 关键字声明
// 常量在编译时确定值，运行时不能修改
// 常量没有类型时，会根据上下文自动推断类型（无类型常量）
//
// 【原理】
// - 常量在编译期间就被替换为具体的值（类似 C 语言的宏）
// - 这意味着运行时不占用额外内存（除非取地址，但常量不能取地址）
//
// 【注意】
// - 常量只能是基本类型：数值、字符串、布尔值
// - 常量不能是切片、map、结构体等复合类型
// - 常量名建议使用驼峰命名（Go 风格）或全大写（其他语言习惯）
// ============================================================================
const (
	AppName    = "Go Learning" // 无类型字符串常量，可以赋值给任何字符串类型
	AppVersion = "1.0.0"       // 同上
)

// ============================================================================
// 【iota 枚举常量】
// ============================================================================
// iota 是 Go 的常量计数器，只能在 const 块中使用
//
// 【原理】
// - iota 在每个 const 块开始时重置为 0
// - 每新增一行常量声明，iota 自动加 1
// - 同一行的多个常量共享同一个 iota 值
//
// 【注意】
// - iota 只在 const 块内递增，不同 const 块互不影响
// - 可以使用 _ 跳过某个值
// - iota 非常适合定义枚举值
// ============================================================================
const (
	Sunday    = iota // iota = 0，所以 Sunday = 0
	Monday           // iota = 1，省略表达式表示沿用上一行的 iota，所以 Monday = 1
	Tuesday          // iota = 2，所以 Tuesday = 2
	Wednesday        // iota = 3，所以 Wednesday = 3
	Thursday         // iota = 4，所以 Thursday = 4
	Friday           // iota = 5，所以 Friday = 5
	Saturday         // iota = 6，所以 Saturday = 6
)

// ============================================================================
// 【带类型的常量】
// ============================================================================
// 显式指定类型的常量，类型转换时更严格
//
// 【原理】
// - 无类型常量（如 Pi = 3.14）可以参与不同类型的运算，编译器会自动转换
// - 带类型常量（如 Pi float64 = 3.14）只能用于匹配类型的运算
//
// 【注意】
// - 带类型常量在类型安全方面更严格
// - 无类型常量更灵活，是 Go 推荐的方式
// ============================================================================
const (
	MaxSize   int     = 1024    // 显式声明为 int 类型
	Pi        float64 = 3.14159 // 显式声明为 float64 类型
	IsEnabled bool    = true    // 显式声明为 bool 类型
)

// ============================================================================
// 【包级别变量（全局变量）】
// ============================================================================
// 在函数外部声明的变量，整个包内都可以访问
//
// 【原理】
// - 包级别变量存储在数据段（Data Segment）中
// - 程序启动时初始化，程序结束时销毁
// - 如果被多个 goroutine 访问，需要考虑并发安全
//
// 【注意】
// - 包级别变量不能使用 := 短声明语法
// - 尽量少用全局变量，它会增加代码耦合度
// - 首字母大写的变量可以被其他包访问（导出）
// ============================================================================
var globalVar = "我是全局变量" // 类型推断为 string

// ============================================================================
// 【main 函数】
// ============================================================================
// 程序的入口点，不接受参数，不返回值
// 命令行参数通过 os.Args 获取
// ============================================================================
func main() {
	fmt.Println("=== Go 变量与常量 ===\n")

	// ========================================================================
	// 【变量声明方式 1：var + 显式类型】
	// ========================================================================
	// 语法: var 变量名 类型 = 值
	//
	// 【原理】
	// - 这是最完整的声明方式，明确指定变量类型
	// - 编译器会检查右边的值是否与声明的类型兼容
	//
	// 【适用场景】
	// - 需要明确类型时（如 var n int64 = 10，避免默认的 int）
	// - 声明接口变量时
	// - 代码可读性要求高时
	//
	// 【注意】
	// - Go 是静态类型语言，变量类型一旦确定就不能改变
	// ========================================================================
	var name string = "Gopher" // 声明 string 类型变量 name，赋值为 "Gopher"
	var age int = 25           // 声明 int 类型变量 age，赋值为 25
	fmt.Printf("显式类型: name=%s, age=%d\n", name, age)
	// %s 是字符串占位符，%d 是十进制整数占位符

	// ========================================================================
	// 【变量声明方式 2：var + 类型推断】
	// ========================================================================
	// 语法: var 变量名 = 值
	//
	// 【原理】
	// - 编译器根据右边的值自动推断变量类型
	// - 整数字面量默认推断为 int
	// - 浮点数字面量默认推断为 float64
	// - 字符串字面量推断为 string
	//
	// 【注意】
	// - 虽然省略了类型，但变量仍然是静态类型的
	// - 推断出的类型在整个生命周期内不会改变
	// ========================================================================
	var city = "Beijing" // 推断为 string
	var score = 98.5     // 推断为 float64（不是 float32！）
	fmt.Printf("类型推断: city=%s, score=%.1f\n", city, score)
	// %.1f 表示保留 1 位小数的浮点数

	// ========================================================================
	// 【变量声明方式 3：短变量声明（:=）】
	// ========================================================================
	// 语法: 变量名 := 值
	//
	// 【原理】
	// - 这是 var + 类型推断的语法糖
	// - := 同时完成声明和赋值
	// - 只能在函数内部使用（不能用于包级别变量）
	//
	// 【注意】
	// - := 左边必须至少有一个新变量，否则编译错误
	// - 如果左边有已存在的变量，则对该变量是赋值而非声明
	// - 这是 Go 中最常用的变量声明方式
	//
	// 【易错点】
	// a := 1
	// a := 2  // 错误！a 已经存在，不能重复声明
	// a = 2   // 正确，这是赋值
	// a, b := 2, 3  // 正确，因为 b 是新变量
	// ========================================================================
	language := "Go"  // 等价于 var language = "Go"
	year := 2009      // 等价于 var year = 2009
	fmt.Printf("短声明: language=%s, year=%d\n", language, year)

	// ========================================================================
	// 【变量声明方式 4：批量声明】
	// ========================================================================
	// 语法:
	// var (
	//     变量1 = 值1
	//     变量2 = 值2
	// )
	//
	// 【适用场景】
	// - 同时声明多个相关的变量
	// - 使代码结构更清晰
	//
	// 【注意】
	// - 批量声明中的变量可以有不同类型
	// - 常量也支持批量声明语法
	// ========================================================================
	var (
		firstName = "张"   // 推断为 string
		lastName  = "三"   // 推断为 string
		isActive  = true  // 推断为 bool
	)
	fmt.Printf("批量声明: %s%s, isActive=%v\n", firstName, lastName, isActive)
	// %v 是通用占位符，可以打印任何类型的值

	// ========================================================================
	// 【变量声明方式 5：多变量同时赋值】
	// ========================================================================
	// 语法: 变量1, 变量2, 变量3 := 值1, 值2, 值3
	//
	// 【原理】
	// - Go 支持元组赋值（tuple assignment）
	// - 右边的值按顺序赋给左边的变量
	// - 所有赋值是同时发生的（这对交换变量很重要）
	//
	// 【适用场景】
	// - 函数返回多个值时接收返回值
	// - 交换两个变量的值
	// - 简化相关变量的声明
	// ========================================================================
	x, y, z := 1, 2, 3 // 同时声明并赋值 x=1, y=2, z=3
	fmt.Printf("多变量赋值: x=%d, y=%d, z=%d\n", x, y, z)

	// ========================================================================
	// 【零值（Zero Value）】
	// ========================================================================
	// Go 的重要特性：所有变量声明后都有确定的初始值
	//
	// 【原理】
	// - 零值保证了变量永远不会处于"未定义"状态
	// - 这避免了很多由未初始化变量导致的 bug
	// - 零值在编译时就确定了，不需要运行时检查
	//
	// 【各类型的零值】
	// - 整数类型: 0
	// - 浮点类型: 0.0
	// - 布尔类型: false
	// - 字符串: "" (空字符串)
	// - 指针/切片/map/channel/函数/接口: nil
	// - 数组: 所有元素都是零值
	// - 结构体: 所有字段都是零值
	//
	// 【注意】
	// - 零值是类型安全的，可以直接使用
	// - 切片和 map 的零值是 nil，但 nil 切片可以安全地使用 len()
	// - nil map 不能写入，只能读取（返回零值）
	// ========================================================================
	fmt.Println("\n--- 零值（未初始化的默认值）---")

	var (
		defaultInt     int       // 零值: 0
		defaultFloat   float64   // 零值: 0.0（打印时显示 0.000000）
		defaultString  string    // 零值: "" (空字符串)
		defaultBool    bool      // 零值: false
		defaultPointer *int      // 零值: nil（空指针）
	)
	fmt.Printf("int零值: %d\n", defaultInt)
	fmt.Printf("float64零值: %f\n", defaultFloat)
	fmt.Printf("string零值: %q\n", defaultString) // %q 带引号显示，可以看到是空字符串 ""
	fmt.Printf("bool零值: %v\n", defaultBool)
	fmt.Printf("pointer零值: %v\n", defaultPointer)

	// ========================================================================
	// 【变量交换】
	// ========================================================================
	// Go 的优雅交换方式，无需临时变量
	//
	// 【原理】
	// - Go 的多重赋值是原子操作
	// - 编译器会先计算右边所有表达式的值，然后同时赋值给左边
	// - 这是语言级别的支持，不是语法糖
	//
	// 【对比其他语言】
	// C/Java: temp = a; a = b; b = temp;
	// Python: a, b = b, a (与 Go 类似)
	// JavaScript (ES6): [a, b] = [b, a]
	// ========================================================================
	fmt.Println("\n--- 变量交换 ---")
	a, b := 10, 20
	fmt.Printf("交换前: a=%d, b=%d\n", a, b)
	a, b = b, a // 同时赋值：a 获得 b 的值，b 获得 a 的值
	fmt.Printf("交换后: a=%d, b=%d\n", a, b)

	// ========================================================================
	// 【常量使用】
	// ========================================================================
	fmt.Println("\n--- 常量 ---")
	fmt.Printf("应用名: %s, 版本: %s\n", AppName, AppVersion)
	fmt.Printf("Pi = %.5f, MaxSize = %d\n", Pi, MaxSize)
	// %.5f 表示保留 5 位小数

	// ========================================================================
	// 【iota 枚举使用】
	// ========================================================================
	fmt.Println("\n--- iota 枚举 ---")
	fmt.Printf("Sunday=%d, Monday=%d, Friday=%d\n", Sunday, Monday, Friday)

	// ========================================================================
	// 【iota 高级用法：位运算定义权限标志】
	// ========================================================================
	// 使用位运算创建可组合的标志位
	//
	// 【原理】
	// - 1 << iota 表示 1 左移 iota 位
	// - iota=0 时: 1 << 0 = 1  (二进制 001)
	// - iota=1 时: 1 << 1 = 2  (二进制 010)
	// - iota=2 时: 1 << 2 = 4  (二进制 100)
	//
	// 【应用场景】
	// - 文件权限: Read=1, Write=2, Execute=4
	// - 可以用 | 组合: ReadWrite = Read | Write = 3
	// - 可以用 & 检查: hasRead = (flag & Read) != 0
	//
	// 【注意】
	// - 这是 Unix 文件权限系统的常见实现方式
	// - 每个标志占用一个位，最多可以定义 64 个标志（int64）
	// ========================================================================
	const (
		FlagRead  = 1 << iota // iota=0, 1 << 0 = 1 (二进制: 001)
		FlagWrite             // iota=1, 1 << 1 = 2 (二进制: 010)
		FlagExec              // iota=2, 1 << 2 = 4 (二进制: 100)
	)
	fmt.Printf("权限标志: Read=%d, Write=%d, Exec=%d\n", FlagRead, FlagWrite, FlagExec)

	// ========================================================================
	// 【iota 跳值：定义存储单位】
	// ========================================================================
	// 使用 _ 跳过 iota 的值
	//
	// 【原理】
	// - _ 是空白标识符，用于忽略值
	// - 第一行 _ = iota 时 iota=0，被忽略
	// - KB = 1 << (10 * iota) 时 iota=1，所以 KB = 1 << 10 = 1024
	// - MB 时 iota=2，所以 MB = 1 << 20 = 1048576
	// - GB 时 iota=3，所以 GB = 1 << 30 = 1073741824
	//
	// 【注意】
	// - 这是定义字节单位常量的经典写法
	// - 利用了 iota 自动递增和位运算的组合
	// ========================================================================
	const (
		_  = iota             // iota=0，使用 _ 跳过，不生成常量
		KB = 1 << (10 * iota) // iota=1, 1 << 10 = 1024 = 1KB
		MB                    // iota=2, 1 << 20 = 1048576 = 1MB
		GB                    // iota=3, 1 << 30 = 1073741824 = 1GB
	)
	fmt.Printf("存储单位: KB=%d, MB=%d, GB=%d\n", KB, MB, GB)

	// ========================================================================
	// 【全局变量访问】
	// ========================================================================
	fmt.Println("\n--- 全局变量 ---")
	fmt.Println(globalVar) // 可以在 main 函数中访问包级别变量

	// ========================================================================
	// 【作用域与变量遮蔽（Shadowing）】
	// ========================================================================
	// Go 的作用域规则和变量遮蔽机制
	//
	// 【原理】
	// - Go 使用词法作用域（Lexical Scoping）
	// - 内层作用域可以访问外层作用域的变量
	// - 内层作用域可以声明同名变量，会"遮蔽"外层变量
	// - 离开内层作用域后，外层变量恢复可见
	//
	// 【作用域层级】
	// 1. 宇宙块（Universe Block）: 预声明的标识符（true, false, nil, int, string 等）
	// 2. 包块（Package Block）: 包级别的声明
	// 3. 文件块（File Block）: import 的包名
	// 4. 函数块/代码块: 局部变量
	//
	// 【注意】
	// - 变量遮蔽可能导致意外的 bug
	// - 使用 go vet -shadow 可以检查变量遮蔽
	// - 避免在内层声明与外层同名的变量
	//
	// 【易错示例】
	// err := doSomething()
	// if err != nil {
	//     result, err := doOther()  // 这里的 err 遮蔽了外层的 err！
	//     // 外层的 err 仍然保持原值
	// }
	// ========================================================================
	fmt.Println("\n--- 作用域 ---")
	outer := "外层变量"
	{
		// 这是一个新的代码块，创建了新的作用域
		inner := "内层变量"              // inner 只在这个块内可见
		outer := "内层同名变量（遮蔽外层）"   // 创建了新的 outer 变量，遮蔽外层的 outer
		fmt.Printf("内层块: outer=%s, inner=%s\n", outer, inner)
		// 此时访问的 outer 是内层的 outer
	}
	// 离开内层块后：
	// - inner 不再可见（编译错误如果尝试访问）
	// - outer 恢复为外层的值
	fmt.Printf("外层块: outer=%s\n", outer) // 输出外层的 "外层变量"

	// ========================================================================
	// 【空白标识符 _】
	// ========================================================================
	// 用于忽略不需要的值
	//
	// 【原理】
	// - _ 是预声明的标识符，可以被赋值但不能被读取
	// - 赋值给 _ 的值会被丢弃
	// - 编译器不会为 _ 分配存储空间
	//
	// 【适用场景】
	// 1. 忽略函数的部分返回值
	// 2. 导入包但只使用其 init 函数（import _ "package"）
	// 3. 确认类型实现了某接口（var _ Interface = (*Type)(nil)）
	// 4. iota 跳值
	//
	// 【注意】
	// - Go 不允许声明了变量却不使用（编译错误）
	// - _ 是唯一可以重复使用的"变量名"
	// - 不能读取 _：fmt.Println(_) 会编译错误
	// ========================================================================
	fmt.Println("\n--- 空白标识符 _ ---")
	result, _ := divmod(10, 3) // 调用 divmod，只保留商，忽略余数
	fmt.Printf("10 / 3 = %d (余数被忽略)\n", result)
}

// ============================================================================
// 【辅助函数：返回商和余数】
// ============================================================================
// Go 函数可以返回多个值，这是 Go 的重要特性
//
// 【原理】
// - 多返回值在底层通过栈或寄存器传递
// - 调用者可以选择接收部分返回值（使用 _）
//
// 【语法说明】
// func 函数名(参数列表) (返回值列表) { 函数体 }
// - (a, b int) 表示 a 和 b 都是 int 类型（简写形式）
// - (int, int) 表示返回两个 int 值
// ============================================================================
func divmod(a, b int) (int, int) {
	return a / b, a % b // 返回商和余数
	// a / b: 整数除法，结果向零取整
	// a % b: 取模运算，结果与 a 同符号
}
