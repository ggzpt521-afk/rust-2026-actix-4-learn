// ============================================================================
// 04_control_flow.go - 流程控制
// ============================================================================
// 运行: go run 04_control_flow.go
//
// 【本文件学习目标】
// 1. 掌握 if 语句及其特殊语法
// 2. 精通 for 循环的各种形式
// 3. 理解 switch 语句的强大功能
// 4. 深入理解 defer 的执行机制
// 5. 掌握 panic 和 recover 的错误处理
// 6. 了解 goto 语句（不推荐使用）
//
// 【Go 流程控制特点】
// - if/for/switch 条件不需要括号
// - for 是唯一的循环语句（没有 while、do-while）
// - switch 默认不穿透（需要 fallthrough 显式穿透）
// - 支持带初始化的 if 和 switch
// - defer 提供延迟执行机制
// ============================================================================

package main

import (
	"fmt"
	"runtime"
	"time"
)

func main() {
	fmt.Println("=== Go 流程控制 ===\n")

	// ========================================================================
	// 【if 语句】
	// ========================================================================
	// Go 的 if 语句不需要括号，但大括号是必须的
	//
	// 【语法】
	// if 条件 {
	//     // 条件为真时执行
	// }
	//
	// 【特点】
	// - 条件必须是布尔表达式，不支持隐式转换
	// - if 1 { } 是错误的，必须写成 if 1 != 0 { }
	// - 大括号不能省略，即使只有一行代码
	// - 左大括号必须与 if 在同一行（Go 的自动分号插入规则）
	// ========================================================================
	fmt.Println("--- if 语句 ---")

	x := 10

	// 基本 if：条件为真时执行
	if x > 5 { // 不需要括号：if (x > 5) 是多余的
		fmt.Println("x > 5")
	}

	// if-else：二选一
	if x%2 == 0 {
		fmt.Println("x 是偶数")
	} else {
		fmt.Println("x 是奇数")
	}

	// if-else if-else：多条件判断
	// 注意：条件从上到下依次判断，满足一个就不再判断后续
	score := 85
	if score >= 90 {
		fmt.Println("优秀")
	} else if score >= 80 {
		fmt.Println("良好")    // 输出这个
	} else if score >= 60 {
		fmt.Println("及格")
	} else {
		fmt.Println("不及格")
	}

	// ========================================================================
	// 【if 带初始化语句】（Go 特色语法）
	// ========================================================================
	// 语法: if 初始化语句; 条件 { }
	//
	// 【原理】
	// - 初始化的变量作用域仅限于 if-else 块
	// - 这是 Go 限制变量作用域的推荐方式
	//
	// 【典型用法】
	// if err := doSomething(); err != nil {
	//     return err
	// }
	// // err 在这里不可访问，避免误用
	// ========================================================================
	if num := 42; num > 40 { // num 只在 if-else 块内有效
		fmt.Printf("num=%d 大于 40\n", num)
	}
	// fmt.Println(num) // 编译错误：num 未定义

	// ========================================================================
	// 【for 循环】
	// ========================================================================
	// Go 只有 for 一种循环语句，但可以表达所有循环形式
	//
	// 【三种形式】
	// 1. 标准 for: for 初始化; 条件; 后置语句 { }
	// 2. while 风格: for 条件 { }
	// 3. 无限循环: for { }
	//
	// 【注意】
	// - 初始化和后置语句可以省略
	// - 条件省略时默认为 true
	// ========================================================================
	fmt.Println("\n--- for 循环 ---")

	// 标准 for 循环（类似 C/Java 的 for）
	fmt.Print("标准 for: ")
	for i := 0; i < 5; i++ { // i 的作用域仅在 for 块内
		fmt.Printf("%d ", i)
	}
	fmt.Println()

	// ========================================================================
	// 【while 风格循环】
	// ========================================================================
	// Go 没有 while 关键字，用 for 条件 { } 代替
	// for 条件 { } 等价于 while(条件) { }
	// ========================================================================
	fmt.Print("while 风格: ")
	j := 0
	for j < 5 { // 只有条件，没有初始化和后置语句
		fmt.Printf("%d ", j)
		j++
	}
	fmt.Println()

	// ========================================================================
	// 【无限循环】
	// ========================================================================
	// for { } 等价于 while(true) { }
	// 必须使用 break 或 return 退出
	// ========================================================================
	fmt.Print("无限循环: ")
	k := 0
	for { // 无限循环
		if k >= 5 {
			break // 必须有退出条件
		}
		fmt.Printf("%d ", k)
		k++
	}
	fmt.Println()

	// ========================================================================
	// 【for-range 遍历】
	// ========================================================================
	// range 用于遍历各种集合类型
	//
	// 【支持的类型】
	// | 类型      | 返回值           |
	// |-----------|------------------|
	// | 数组/切片 | index, value     |
	// | 字符串    | index, rune      |
	// | map       | key, value       |
	// | channel   | value            |
	//
	// 【注意】
	// - range 返回的是元素的副本，修改它不会影响原集合
	// - 可以用 _ 忽略不需要的返回值
	// ========================================================================
	fmt.Print("遍历切片: ")
	nums := []int{10, 20, 30, 40, 50}
	for index, value := range nums { // 同时获取索引和值
		fmt.Printf("[%d]=%d ", index, value)
	}
	fmt.Println()

	// 只需要索引
	fmt.Print("只要索引: ")
	for i := range nums { // 省略第二个变量
		fmt.Printf("%d ", i)
	}
	fmt.Println()

	// 只需要值
	fmt.Print("只要值: ")
	for _, v := range nums { // 用 _ 忽略索引
		fmt.Printf("%d ", v)
	}
	fmt.Println()

	// ========================================================================
	// 【遍历字符串】
	// ========================================================================
	// range 遍历字符串时返回 (字节索引, rune)
	// 注意：索引是字节位置，不是字符位置
	// 中文字符占 3 字节，所以索引会跳跃
	// ========================================================================
	fmt.Println("遍历字符串:")
	str := "Go语言"
	for i, ch := range str {
		fmt.Printf("  索引 %d: %c (Unicode: %U)\n", i, ch, ch)
		// 输出:
		// 索引 0: G (Unicode: U+0047)
		// 索引 1: o (Unicode: U+006F)
		// 索引 2: 语 (Unicode: U+8BED)  <- 注意索引跳到 2，因为中文占 3 字节
		// 索引 5: 言 (Unicode: U+8A00)
	}

	// ========================================================================
	// 【遍历 map】
	// ========================================================================
	// map 的遍历顺序是随机的（每次运行可能不同）
	// 如果需要有序遍历，先获取 key 排序
	// ========================================================================
	fmt.Println("遍历 map:")
	ages := map[string]int{"Alice": 25, "Bob": 30, "Charlie": 35}
	for name, age := range ages {
		fmt.Printf("  %s: %d\n", name, age)
	}

	// ========================================================================
	// 【break 和 continue】
	// ========================================================================
	// break: 跳出当前循环
	// continue: 跳过本次迭代，进入下一次
	// ========================================================================
	fmt.Print("break 示例: ")
	for i := 0; i < 10; i++ {
		if i == 5 {
			break // 当 i=5 时跳出循环
		}
		fmt.Printf("%d ", i)
	}
	fmt.Println()
	// 输出: 0 1 2 3 4

	fmt.Print("continue 示例: ")
	for i := 0; i < 10; i++ {
		if i%2 == 0 {
			continue // 跳过偶数
		}
		fmt.Printf("%d ", i)
	}
	fmt.Println()
	// 输出: 1 3 5 7 9

	// ========================================================================
	// 【带标签的 break/continue】
	// ========================================================================
	// 用于在嵌套循环中跳出或继续外层循环
	//
	// 【语法】
	// label:
	// for ... {
	//     for ... {
	//         break label    // 跳出带 label 的循环
	//         continue label // 继续带 label 的循环的下一次迭代
	//     }
	// }
	//
	// 【注意】
	// - 标签必须紧跟在 for、switch 或 select 之前
	// - 减少使用，过多标签会降低可读性
	// ========================================================================
	fmt.Println("带标签的循环:")
outer: // 标签
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			if i == 1 && j == 1 {
				fmt.Println("  在 i=1, j=1 处跳出外层循环")
				break outer // 跳出外层循环，不只是内层
			}
			fmt.Printf("  i=%d, j=%d\n", i, j)
		}
	}

	// ========================================================================
	// 【switch 语句】
	// ========================================================================
	// Go 的 switch 功能强大，与 C/Java 有显著不同
	//
	// 【特点】
	// - 不需要 break，默认不穿透
	// - case 可以是表达式，不限于常量
	// - 一个 case 可以匹配多个值
	// - 可以没有表达式（类似 if-else 链）
	// - 支持类型 switch
	//
	// 【与 C/Java 对比】
	// | 特性       | Go           | C/Java          |
	// |------------|--------------|-----------------|
	// | 默认行为   | 不穿透       | 穿透            |
	// | 穿透语法   | fallthrough  | 省略 break      |
	// | case 值    | 可以是表达式 | 必须是常量      |
	// | 多值匹配   | case 1, 2:   | 需要多个 case   |
	// ========================================================================
	fmt.Println("\n--- switch 语句 ---")

	// 基本 switch
	day := 3
	switch day {
	case 1:
		fmt.Println("星期一")
	case 2:
		fmt.Println("星期二")
	case 3:
		fmt.Println("星期三") // 匹配这个，不需要 break
	case 4:
		fmt.Println("星期四")
	case 5:
		fmt.Println("星期五")
	case 6, 7: // 多值匹配：6 或 7 都匹配
		fmt.Println("周末")
	default: // 默认情况，可选
		fmt.Println("无效日期")
	}

	// ========================================================================
	// 【switch 带初始化】
	// ========================================================================
	// 类似 if 的初始化语句，限制变量作用域
	// ========================================================================
	switch today := time.Now().Weekday(); today {
	case time.Saturday, time.Sunday:
		fmt.Printf("今天是 %v，是周末\n", today)
	default:
		fmt.Printf("今天是 %v，是工作日\n", today)
	}

	// ========================================================================
	// 【无表达式 switch】
	// ========================================================================
	// 当 switch 后没有表达式时，case 是布尔表达式
	// 这是一种比 if-else 链更清晰的写法
	// ========================================================================
	hour := time.Now().Hour()
	switch { // 没有表达式
	case hour < 6:
		fmt.Println("凌晨")
	case hour < 12:
		fmt.Println("上午")
	case hour < 18:
		fmt.Println("下午")
	default:
		fmt.Println("晚上")
	}

	// ========================================================================
	// 【fallthrough 关键字】
	// ========================================================================
	// 显式穿透到下一个 case（无论下一个 case 条件如何）
	//
	// 【注意】
	// - fallthrough 必须是 case 块的最后一条语句
	// - fallthrough 不会判断下一个 case 的条件，强制执行
	// - 很少使用，使用时要小心
	// ========================================================================
	fmt.Println("\nfallthrough 示例:")
	n := 1
	switch n {
	case 1:
		fmt.Println("case 1")
		fallthrough // 穿透到 case 2
	case 2:
		fmt.Println("case 2 (fallthrough)")
		fallthrough // 穿透到 case 3
	case 3:
		fmt.Println("case 3 (fallthrough)")
		// 没有 fallthrough，停止
	default:
		fmt.Println("default")
	}
	// 输出: case 1, case 2, case 3

	// ========================================================================
	// 【类型 switch】
	// ========================================================================
	// 用于判断接口变量的动态类型
	//
	// 【语法】
	// switch v := x.(type) {
	// case Type1:
	//     // v 的类型是 Type1
	// case Type2:
	//     // v 的类型是 Type2
	// }
	//
	// 【注意】
	// - x.(type) 只能在 switch 中使用
	// - 普通类型断言用 v, ok := x.(Type)
	// ========================================================================
	fmt.Println("\n类型 switch:")
	printType(42)            // 整数
	printType("hello")       // 字符串
	printType(3.14)          // 浮点数
	printType(true)          // 布尔值
	printType([]int{1, 2, 3}) // 切片

	// ========================================================================
	// 【defer 语句】
	// ========================================================================
	// defer 将函数调用推迟到外层函数返回时执行
	//
	// 【执行时机】
	// 1. 包含 defer 的函数返回时
	// 2. 包含 defer 的函数发生 panic 时
	// 3. 调用 runtime.Goexit 时
	//
	// 【执行顺序】
	// - 多个 defer 按 LIFO（后进先出）顺序执行
	// - 类似栈：最后 defer 的最先执行
	//
	// 【参数求值】
	// - defer 语句的参数在 defer 时立即求值
	// - 不是在实际执行时求值（这是常见陷阱）
	//
	// 【典型用法】
	// - 资源清理：关闭文件、释放锁、关闭连接
	// - 记录日志：函数进入/退出
	// - 处理 panic：配合 recover
	// ========================================================================
	fmt.Println("\n--- defer 语句 ---")

	// 基本 defer
	fmt.Println("defer 基本用法:")
	deferBasic()

	// defer 与函数返回值
	fmt.Println("\ndefer 与返回值:")
	fmt.Printf("deferReturnValue() = %d\n", deferReturnValue())

	// defer 捕获变量
	fmt.Println("\ndefer 捕获变量:")
	deferCapture()

	// defer 在循环中（注意内存）
	fmt.Println("\ndefer 在循环中:")
	deferInLoop()

	// ========================================================================
	// 【panic 和 recover】
	// ========================================================================
	// panic: 引发运行时恐慌，程序会终止
	// recover: 捕获 panic，允许程序继续执行
	//
	// 【panic 触发场景】
	// - 显式调用 panic(value)
	// - 数组越界
	// - 空指针解引用
	// - 类型断言失败（不带 ok）
	// - 向已关闭的 channel 发送数据
	//
	// 【recover 规则】
	// - 只能在 defer 函数中调用
	// - 如果没有 panic，recover 返回 nil
	// - recover 捕获 panic 后，程序继续执行
	//
	// 【最佳实践】
	// - panic 用于不可恢复的错误
	// - 正常错误处理用 error 返回值
	// - 库代码应该避免 panic，返回 error
	// - 只在必要的边界处（如 HTTP handler）使用 recover
	// ========================================================================
	fmt.Println("\n--- panic 和 recover ---")
	safeDivide(10, 2)  // 正常执行
	safeDivide(10, 0)  // 会触发 panic，但被 recover 捕获
	fmt.Println("程序继续执行...") // 这行会执行，因为 panic 被捕获了

	// ========================================================================
	// 【goto 语句】
	// ========================================================================
	// 无条件跳转到指定标签
	//
	// 【语法】
	// goto label
	// ...
	// label:
	//
	// 【限制】
	// - 不能跳过变量声明
	// - 不能跳入其他函数
	// - 不能跳入代码块（如 if、for 内部）
	//
	// 【注意】
	// - 强烈不推荐使用
	// - 会导致代码难以理解和维护
	// - 几乎所有场景都有更好的替代方案
	// - 仅在极少数情况下（如跳出多层嵌套）才考虑使用
	// ========================================================================
	fmt.Println("\n--- goto 语句（不推荐使用）---")
	gotoDemo()

	// ========================================================================
	// 【运行时信息】
	// ========================================================================
	// runtime 包提供与 Go 运行时系统交互的功能
	// ========================================================================
	fmt.Println("\n--- 运行时信息 ---")
	fmt.Printf("操作系统: %s\n", runtime.GOOS)     // 如 "darwin", "linux", "windows"
	fmt.Printf("CPU 架构: %s\n", runtime.GOARCH)   // 如 "amd64", "arm64"
	fmt.Printf("Go 版本: %s\n", runtime.Version()) // 如 "go1.21.0"
	fmt.Printf("CPU 核心数: %d\n", runtime.NumCPU()) // 逻辑 CPU 数量
}

// ============================================================================
// 【类型 switch 示例函数】
// ============================================================================
// interface{} 可以接受任何类型的值
// v.(type) 只能在 switch 语句中使用
// ============================================================================
func printType(v interface{}) {
	switch t := v.(type) { // t 在每个 case 中有不同的具体类型
	case int:
		fmt.Printf("  整数: %d\n", t) // t 是 int 类型
	case string:
		fmt.Printf("  字符串: %s\n", t) // t 是 string 类型
	case float64:
		fmt.Printf("  浮点数: %.2f\n", t) // t 是 float64 类型
	case bool:
		fmt.Printf("  布尔值: %v\n", t) // t 是 bool 类型
	default:
		fmt.Printf("  未知类型: %T\n", t) // %T 打印类型名
	}
}

// ============================================================================
// 【defer 基本用法】
// ============================================================================
// 演示 defer 的 LIFO 执行顺序
// ============================================================================
func deferBasic() {
	defer fmt.Println("  3. defer (最后执行)")   // 第三个注册，最后执行
	defer fmt.Println("  2. defer (倒数第二)")   // 第二个注册，倒数第二执行
	fmt.Println("  1. 正常执行")                // 立即执行
	// 函数返回时，按 LIFO 顺序执行 defer
}

// ============================================================================
// 【defer 与命名返回值】
// ============================================================================
// defer 可以修改命名返回值
//
// 【执行流程】
// 1. result = 10（return 语句赋值）
// 2. 执行 defer（result++）
// 3. 返回 result（现在是 11）
// ============================================================================
func deferReturnValue() (result int) {
	defer func() {
		result++ // 在 return 之后、函数真正返回之前执行
	}()
	return 10 // 实际返回 11
}

// ============================================================================
// 【defer 捕获变量】
// ============================================================================
// defer 的参数在 defer 时求值
//
// 【常见陷阱】
// for i := 0; i < 3; i++ {
//     defer fmt.Println(i) // 每次 defer 时 i 的值被捕获
// }
// 输出: 2, 1, 0（LIFO 顺序，但值是捕获时的值）
// ============================================================================
func deferCapture() {
	for i := 0; i < 3; i++ {
		// i 的值在 defer 时就被求值并保存
		defer fmt.Printf("  值捕获 i=%d\n", i)
	}
	// 输出顺序: i=2, i=1, i=0（LIFO）
	// 但每个 i 的值是 defer 时的值，不是函数返回时的值
}

// ============================================================================
// 【defer 在循环中的正确用法】
// ============================================================================
// 在循环中使用 defer 要小心：
// - defer 不会在每次迭代后执行，而是在函数返回时执行
// - 可能导致资源占用过多
//
// 【解决方案】
// 1. 将循环体包装在匿名函数中
// 2. 使用显式的资源管理（不用 defer）
// ============================================================================
func deferInLoop() {
	for i := 0; i < 3; i++ {
		// 包装在匿名函数中，每次迭代后 defer 立即执行
		func(n int) {
			defer fmt.Printf("  闭包内 defer n=%d\n", n)
			// 匿名函数返回时，defer 执行
		}(i)
	}
	// 输出: n=0, n=1, n=2（按迭代顺序，因为每次都在匿名函数中执行）
}

// ============================================================================
// 【panic 和 recover 示例】
// ============================================================================
// 演示如何安全地处理可能的 panic
//
// 【模式】
// func safeFunc() {
//     defer func() {
//         if r := recover(); r != nil {
//             // 处理 panic
//         }
//     }()
//     // 可能 panic 的代码
// }
// ============================================================================
func safeDivide(a, b int) {
	// defer + recover 捕获 panic
	defer func() {
		if r := recover(); r != nil { // recover() 返回 panic 的值
			fmt.Printf("  捕获到 panic: %v\n", r)
		}
	}()

	if b == 0 {
		panic("除数不能为零") // 触发 panic
	}
	fmt.Printf("  %d / %d = %d\n", a, b, a/b)
}

// ============================================================================
// 【goto 示例】
// ============================================================================
// 不推荐使用 goto，仅作演示
// 这个例子用 goto 模拟了一个 while 循环
// ============================================================================
func gotoDemo() {
	i := 0
loop: // 标签
	if i < 3 {
		fmt.Printf("  i = %d\n", i)
		i++
		goto loop // 跳转到 loop 标签
	}
	fmt.Println("  循环结束")
	// 更好的写法是用 for 循环
}
