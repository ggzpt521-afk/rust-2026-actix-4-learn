# Go 语言学习示例

这是一套系统覆盖 Go 语言核心特性的学习示例，包含 15 个主题，从基础到进阶，每个文件都可以独立运行。

## 环境要求

- Go 1.21+ (推荐 1.22+)
- 部分特性需要 Go 1.18+（泛型）或 Go 1.21+（min/max/clear 函数）

## Go 语言核心特性

### 类型系统

Go 是**静态强类型**语言：

| 特性 | 说明 |
|------|------|
| **静态类型** | 变量类型在编译时确定，运行时不能改变类型 |
| **强类型** | 不同类型之间不能隐式转换，必须显式转换 |
| **类型推断** | 使用 `:=` 时编译器自动推断类型，但类型仍然是固定的 |

```go
var x int = 10      // 显式类型
y := 20             // 类型推断为 int，之后不能改变
x = 30              // ✓ 可以修改值
// x = "hello"      // ✗ 编译错误：不能将 string 赋给 int
// x = 3.14         // ✗ 编译错误：不能将 float64 赋给 int（需显式转换）
x = int(3.14)       // ✓ 显式转换
```

### 变量与值的修改

| 操作 | 是否允许 | 说明 |
|------|----------|------|
| 修改变量的**值** | ✓ | `x = 20` |
| 修改变量的**类型** | ✗ | 编译时确定，运行时不可变 |
| 类型转换 | ✓ | 必须显式：`float64(x)` |

### 与其他语言对比

| 语言 | 类型系统 | 变量类型可变 |
|------|----------|--------------|
| **Go** | 静态强类型 | ✗ 编译时固定 |
| Rust | 静态强类型 | ✗ 编译时固定 |
| Java | 静态强类型 | ✗ 编译时固定 |
| C | 静态弱类型 | ✗（但有隐式转换） |
| Python | 动态强类型 | ✓ 运行时可变 |
| JavaScript | 动态弱类型 | ✓ 运行时可变 |

### 其他核心特性

- **编译型语言**：编译为机器码，执行效率高
- **垃圾回收（GC）**：自动内存管理，无需手动释放
- **并发原生支持**：goroutine 和 channel 是语言内置特性
- **简洁语法**：只有 25 个关键字
- **快速编译**：大型项目也能秒级编译
- **单一二进制**：编译产物为单个可执行文件，无依赖

维度 |	Struct (结构体                          |	Interface (接口)
本质 |	具体实现 (Data + Methods)	           |抽象契约 (Behavior only)
关系|	无需声明，只要方法签名匹配，自动建立关系	|定义标准，不关心具体是谁实现的
内存原理|	存储具体的字段值	                 |  存储 (具体类型信息指针, 具体数据指针)
优势	|高效、内存布局紧凑	                    |   灵活、解耦、多态

Struct 只管把事做了（实现功能）。
Interface 只管把需求提了（定义抽象）。
使用者根据需求组合它们，而不是在定义时就死死绑定。

### 零值（Zero Value）

Go 中未初始化的变量会自动赋予零值：

| 类型 | 零值 |
|------|------|
| 整数 | `0` |
| 浮点数 | `0.0` |
| 布尔 | `false` |
| 字符串 | `""` (空字符串) |
| 指针/切片/map/channel/函数/接口 | `nil` |

这俩兄弟是 Go 语言（以及大多数现代编程语言）中非常核心的概念。

简单的概括：

* **匿名函数**是**“肉体”**（一段没有名字的代码）。
* **闭包**是**“肉体 + 灵魂”**（代码 + 它引用的外部环境）。

下面我们深入剖析它们的原理。

---

### 一、 匿名函数 (Anonymous Function)

顾名思义，就是**没有名字的函数**。

在 Go 语言中，函数是“一等公民”（First-class Citizen），这意味着函数可以像普通变量一样：

1. 赋值给变量。
2. 作为参数传给别的函数。
3. 作为别的函数的返回值。

#### 1. 怎么写？

```go
func main() {
    // 1. 定义并赋值给变量
    add := func(a, b int) int {
        return a + b
    }
    fmt.Println(add(1, 2)) // 调用

    // 2. 定义并立即执行 (IIFE)
    func() {
        fmt.Println("我是立即执行的匿名函数")
    }()
}

```

#### 2. 用途

通常用于**一次性逻辑**，比如启动一个 Goroutine：

```go
go func() {
    fmt.Println("我在协程里跑")
}()

```

---

### 二、 闭包 (Closure) —— 重点与难点

#### 1. 什么是闭包？

官方定义比较拗口，我给你一个**通俗的公式**：

> **闭包 = 一个函数 + 这个函数外部的变量**

当一个匿名函数引用了**定义在它外部**的变量时，这个匿名函数就变成了“闭包”。

#### 2. 核心特性：它自带“背包”

最神奇的地方在于：**即使那个定义外部变量的父函数已经结束了，闭包依然能访问并修改那个变量。**

就像这个函数出门时，背了一个**背包**，把它需要的外部变量都打包带走了。

#### 3. 经典案例：计数器

这是理解闭包的“Hello World”：

```go
//这个函数返回的是一个函数（闭包）
func createCounter() func() int {
    count := 0 // 这是一个外部变量

    // 返回一个匿名函数，它引用了 count
    return func() int {
        count++ // 它可以修改外面的 count
        return count
    }
}

func main() {
    // 创建一个计数器实例
    c1 := createCounter()

    fmt.Println(c1()) // 输出 1
    fmt.Println(c1()) // 输出 2
    fmt.Println(c1()) // 输出 3 (它记得之前的状态！)

    // 创建另一个全新的计数器
    c2 := createCounter()
    fmt.Println(c2()) // 输出 1 (c1 和 c2 的背包是独立的)
}

```

**解析：** `count` 变量本来属于 `createCounter` 函数，按理说函数执行完栈就销毁了，变量也没了。但因为被内部函数引用了，它“活”了下来。

---

### 三、 闭包的底层原理 (面试必问)

你可能会问：**“为什么父函数销毁了，局部变量还能存在？存在哪儿了？”**

这涉及 Go 编译器的**逃逸分析 (Escape Analysis)**。

#### 1. 栈 (Stack) vs 堆 (Heap)

* **正常情况：** 函数的局部变量分配在**栈**上。函数结束，栈帧弹出，变量销毁。
* **闭包情况：**
1. 编译器扫描代码，发现 `createCounter` 里的变量 `count` 被返回的闭包引用了。
2. 编译器判定：这个变量**不能**随着 `createCounter` 的结束而销毁。
3. **逃逸：** 编译器会把 `count` 变量从**栈**上搬运到**堆 (Heap)** 上分配。
4. **结果：** 即使栈被销毁，堆上的 `count` 依然存在，且由 GC（垃圾回收）来管理它的生命周期。



#### 2. 引用传递

闭包里对外部变量的访问是**引用传递**（或者说指针访问），而不是值拷贝。

这意味着，如果在闭包里修改了变量，所有引用这个变量的地方都会感知到变化。

---

### 四、 必须要小心的一个坑：循环变量

这是 Go 语言最经典的面试坑（虽然 Go 1.22 版本已经修复了这个问题，但理解其原理依然重要）。

#### 场景：在循环里启动协程

```go
// 假设这是 Go 1.21 或更早版本
func main() {
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func() { // 这是一个闭包
            fmt.Println(i) // 引用了外部的 i
            wg.Done()
        }()
    }
    wg.Wait()
}

```

* **你期望的输出：** 0, 1, 2 (顺序可能乱，但数字对)
* **实际的输出 (Go 1.21及以前)：** 3, 3, 3 （甚至全是 2）

#### 为什么？

因为闭包引用的是变量 `i` 的**地址**。

1. 循环跑得非常快，瞬间就把 `i` 加到了 3。
2. 协程启动需要时间（分配栈、调度），等它们真正开始执行打印时，外面的 `i` 早就变成 3 了。
3. 三个协程看的是同一个地址里的 `i`，所以大家都打印 3。

#### 怎么修？

你需要在这个“背包”打包的一瞬间，把当前的 `i` 复制一份存进去。

**写法 1：作为参数传进去 (最推荐)**

```go
go func(val int) { // 这里接收参数
    fmt.Println(val)
}(i) // 这里传值，发生拷贝

```

**写法 2：局部变量覆盖**

```go
for i := 0; i < 3; i++ {
    i := i // "Shadowing": 创建一个新的局部变量 i，捕获当前的循环值
    go func() {
        fmt.Println(i)
    }()
}

```

> **注：Go 1.22 版本更新**
> 从 Go 1.22 开始，官方修改了 `for` 循环的语义，每次循环都会自动隐式地创建一个新的变量。所以上面的“坑”在最新版 Go 中已经不复存在了，直接写也能输出 0, 1, 2。

---

### 总结一张表

| 特性 | 匿名函数 | 闭包 |
| --- | --- | --- |
| **定义** | 没有名字的函数 | 匿名函数 + 捕获的外部环境 |
| **关注点** | 语法结构 | 状态保持 (Stateful) |
| **数据存储** | 仅处理参数和内部变量 | 变量可能会逃逸到**堆 (Heap)** |
| **主要作用** | 回调、一次性任务、延迟执行 | 封装数据、中间件、函数式编程 |

**简单说：闭包就是自带“记忆”功能的函数。**
## Go 编译原理

### 编译流程

```
源代码 (.go)
    ↓
┌─────────────────┐
│  词法分析       │  将源码转换为 token 序列
│  (Lexer)        │
└─────────────────┘
    ↓
┌─────────────────┐
│  语法分析       │  构建抽象语法树 (AST)
│  (Parser)       │
└─────────────────┘
    ↓
┌─────────────────┐
│  类型检查       │  类型推断、类型验证
│  (Type Check)   │
└─────────────────┘
    ↓
┌─────────────────┐
│  中间代码生成   │  生成 SSA (Static Single Assignment)
│  (SSA)          │
└─────────────────┘
    ↓
┌─────────────────┐
│  机器码生成     │  生成目标平台的机器码
│  (Code Gen)     │
└─────────────────┘
    ↓
┌─────────────────┐
│  链接           │  静态链接，生成可执行文件
│  (Linker)       │
└─────────────────┘
    ↓
可执行文件 (单一二进制)
```

### 编译特点

| 特性 | 说明 |
|------|------|
| **静态编译** | 编译为机器码，不依赖虚拟机 |
| **静态链接** | 所有依赖打包进单一二进制文件 |
| **交叉编译** | 轻松编译其他平台的可执行文件 |
| **快速编译** | 依赖分析高效，增量编译 |

```bash
# 交叉编译示例
GOOS=linux GOARCH=amd64 go build    # 编译 Linux 版本
GOOS=windows GOARCH=amd64 go build  # 编译 Windows 版本
GOOS=darwin GOARCH=arm64 go build   # 编译 macOS ARM 版本
```

## 内存管理原理

### 内存布局

```
┌─────────────────────────────────────────┐
│                 栈 (Stack)               │  ← 函数调用、局部变量
│  • 自动分配和释放                         │     每个 goroutine 独立栈
│  • 初始 2KB，可动态增长                   │     最大可达 1GB
├─────────────────────────────────────────┤
│                 堆 (Heap)                │  ← 动态分配、逃逸的变量
│  • 由 GC 管理                            │     所有 goroutine 共享
│  • 分级管理 (mcache/mcentral/mheap)      │
└─────────────────────────────────────────┘
```

### 内存分配器（基于 TCMalloc 思想）

Go 的内存分配采用**多级缓存**架构，减少锁竞争：

```
┌─────────────────────────────────────────────────────────┐
│                      mheap (全局堆)                      │
│  • 管理所有堆内存                                        │
│  • 以 8KB 为单位的 page 管理                             │
│  • 需要加锁访问                                          │
└─────────────────────────────────────────────────────────┘
                            ↑
┌─────────────────────────────────────────────────────────┐
│                 mcentral (中心缓存)                      │
│  • 按 size class 分类管理                               │
│  • 为各 P 的 mcache 提供 span                           │
│  • 需要加锁，但粒度比 mheap 小                           │
└─────────────────────────────────────────────────────────┘
                            ↑
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│   mcache     │  │   mcache     │  │   mcache     │
│   (P0 本地)  │  │   (P1 本地)  │  │   (P2 本地)  │
│  • 无锁访问  │  │  • 无锁访问  │  │  • 无锁访问  │
└──────────────┘  └──────────────┘  └──────────────┘
```

### 对象大小分类

| 类别 | 大小 | 分配方式 |
|------|------|----------|
| **Tiny** | < 16B (无指针) | 多个对象合并到一个 16B 块 |
| **Small** | 16B ~ 32KB | 从 mcache 的 span 分配 |
| **Large** | > 32KB | 直接从 mheap 分配 |

### 逃逸分析（Escape Analysis）

编译器决定变量分配在**栈**还是**堆**：

```go
// 栈分配（不逃逸）
func stackAlloc() int {
    x := 10       // x 只在函数内使用
    return x      // 返回值拷贝
}

// 堆分配（逃逸）
func heapAlloc() *int {
    x := 10       // x 的地址被返回
    return &x     // 逃逸到堆！
}

// 查看逃逸分析
// go build -gcflags="-m" main.go
```

**逃逸场景：**

| 场景 | 示例 | 原因 |
|------|------|------|
| 返回局部变量指针 | `return &x` | 函数返回后变量仍需存活 |
| 发送指针到 channel | `ch <- &x` | 可能被其他 goroutine 访问 |
| 闭包引用外部变量 | `func() { use(x) }` | 闭包可能逃逸 |
| interface{} 参数 | `fmt.Println(x)` | 运行时才知道类型 |
| 切片扩容 | `append(s, x)` | 可能重新分配 |

### 垃圾回收（GC）

Go 使用**并发三色标记清除**算法：

#### 三色标记法

```
┌─────────┐     ┌─────────┐     ┌─────────┐
│  白色   │     │  灰色   │     │  黑色   │
│  White  │ ──→ │  Gray   │ ──→ │  Black  │
├─────────┤     ├─────────┤     ├─────────┤
│ 未访问  │     │ 已访问  │     │ 已访问  │
│ 可能是  │     │ 子对象  │     │ 子对象  │
│ 垃圾    │     │ 待处理  │     │ 已处理  │
└─────────┘     └─────────┘     └─────────┘
```

**标记过程：**
结局： 如果标记过程彻底结束了，它还是白色，说明没有任何人能联系到它，它就是垃圾，会被回收。

1. **初始状态**：所有对象为白色
2. **标记开始**：根对象（栈、全局变量）标记为灰色
3. **标记传播**：
   - 取出灰色对象
   - 将其引用的白色对象标记为灰色
   - 将自身标记为黑色
4. **标记结束**：没有灰色对象时结束
5. **清除**：回收所有白色对象

#### 写屏障（Write Barrier）

为了实现**并发标记**，使用写屏障保证正确性：

```go
// 伪代码：混合写屏障 (Go 1.8+)
func writePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(*slot)  // 原指针标灰（删除屏障）
    shade(ptr)    // 新指针标灰（插入屏障）
    *slot = ptr
}
```

#### GC 触发条件

| 触发方式 | 条件 |
|----------|------|
| **阈值触发** | 堆内存达到上次 GC 后的 2 倍（GOGC=100） |
通俗解释： “垃圾攒够了一定比例再扫”。

详细逻辑：

Go 语言有一个环境变量叫 GOGC，默认值是 100（代表 100%）。

基准线： 假设上一次打扫完，家里剩下了 10MB 的东西（存活对象）。

触发线： 因为 GOGC=100，意味着当新产生的垃圾让内存总量增长了 100% 时（也就是总量达到 20MB 时），机器人就会启动。

动态变化： 如果这次扫完，家里东西变多了，剩下 50MB，那下次就要等到 100MB 才会触发。它会根据当前内存的使用情况动态调整。
| **定时触发** | 超过 2 分钟没有 GC |
| **手动触发** | `runtime.GC()` |

#### GC 调优

```bash
# 环境变量
GOGC=100       # 默认值，堆增长 100% 时触发 GC
GOGC=200       # 减少 GC 频率，增加内存使用
GOGC=50        # 增加 GC 频率，减少内存使用
GOGC=off       # 关闭 GC（危险！）

GOMEMLIMIT=1GiB  # Go 1.19+，设置内存上限
```

## Goroutine 原理

### Goroutine vs 线程

| 特性 | Goroutine | OS 线程 |
|------|-----------|---------|
| **栈大小** | 初始 2KB，动态增长 | 固定 1-8MB |
| **创建成本** | ~0.3μs | ~30μs |
| **切换成本** | ~0.2μs（用户态） | ~1-5μs（内核态） |
| **数量** | 可创建数十万个 | 通常数千个 |
| **调度** | Go runtime（用户态） | OS 内核 |

### GMP 调度模型

```
这段 ASCII 图和流程图极其精准地描述了 **Go 语言并发调度的核心——GMP 模型**。

Go 语言之所以能轻松支持百万级并发（Goroutine），完全归功于这个设计。下面我为你把这张“藏宝图”翻译成通俗易懂的“工厂运作手册”。

---

### 第一部分：三大核心角色 (G, M, P)

你可以把整个 Go 运行时（Runtime）想象成一个**大型搬砖工地**。

#### 1. G (Goroutine) —— **“砖头” (任务)**

* **含义：** 协程，代码执行的实体。
* **包含：** 你的代码逻辑、独立的栈内存（初始 2KB，可动态扩容）、当前的执行位置（PC）。
* **特点：** 非常轻量。工地上成千上万块砖头等着被搬运。

#### 2. M (Machine) —— **“工人” (执行者)**

* **含义：** 操作系统内核线程（OS Thread）。
* **作用：** 它是真正干活的苦力。CPU 只能看到 M，看不到 G。
* **特点：** 创建和切换很贵（耗费资源），所以 M 的数量通常有限，不能太多。

#### 3. P (Processor) —— **“手推车” (资源/上下文)**

* **含义：** 逻辑处理器（默认数量 = CPU 核数）。
* **作用：** 这是 GMP 模型最天才的设计！
* 它维护了一个**本地队列（Local Queue）**，里面装着待处理的 G。
* **M 必须拿到 P 才能干活**。如果不引入 P，所有的 M 都要去抢同一个全局队列里的 G，那锁的竞争（Lock Contention）会把系统拖垮。


* **特点：** 有了 P，M 就可以从 P 的本地队列里拿任务，不用频繁加锁，速度飞快。

---

### 第二部分：调度流程详解 (那张流程图)

这就是一个**工人（M）**推着**车（P）**搬运**砖头（G）**的过程。

#### 1. 优先吃“窝边草” (从 P 本地队列获取)

* **动作：** M 想要干活，首先看自己手推车（P 的本地队列）里有没有 G。
* **优势：** **无锁（Lock-free）**。因为这个 P 此时归这个 M 独占，没人跟它抢，所以取任务速度极快，性能最高。

#### 2. 没草吃怎么办？ (队列为空)

如果手推车空了，M 不会马上休息，它会根据规则去找活干（对应流程图的分支）：

* **路径 A：去全局队列（Global Queue）拿**
* 全局队列是所有 P 共享的“大仓库”。
* **缺点：** 既然是共享的，去这里拿 G 必须**加锁**（互斥锁）。
* **机制：** 为了避免全局队列里的 G 饿死，调度器其实每调度 61 次本地 G，就会强制去全局队列看一眼。


* **路径 B：工作窃取 (Work Stealing)**
* **这是 Go 调度器最骚的操作。**
* 如果全局队列也没了，M 会去**偷**其他 P 的本地队列。
* **规则：** 通常会把别人队列里**一半**的 G 偷过来放到自己的 P 里。
* **意义：** 实现了**负载均衡**。保证所有 CPU 核都在忙，不会出现“一核有难，七核围观”的现象。



#### 3. 执行 G (Execute)

* M 拿到了 G，开始运行代码。
* **时间片：** 就像操作系统一样，Go 也会防止一个 G 霸占 CPU 太久。通常一个 G 最多跑 **10ms**，如果还没跑完，会被强制暂停（抢占式调度），放回队列，让别的 G 跑。

#### 4. G 完成或阻塞

* **完成：** G 代码跑完了，被销毁。
* **阻塞（重点）：** 如果 G 要进行系统调用（比如读文件、网络请求），M 可能会被阻塞住。
* 此时，**P 会把这个阻塞的 M 甩掉（Handover）**，带着本地队列去寻找（或创建）一个新的 M 继续干活。
* 这就是为什么 Go 的 I/O 并发性能这么高的原因：**干活的上下文（P）永远在流转，不会因为某个线程（M）卡住而停摆。**



---

### 总结：为什么 GMP 这么强？

如果把这个系统看作一家快递公司：

* **G** 是包裹。
* **M** 是快递员。
* **P** 是快递车。

**传统的线程模型**（没有 P）是：所有快递员（M）都去一个总仓库（全局队列）抢包裹（G），门口挤破头（锁竞争严重）。

**GMP 模型**是：每个快递员（M）配一辆车（P），车上预先装了一堆包裹（本地队列）。

1. 快递员直接从车上拿包裹送（**本地获取，无锁，快**）。
2. 车空了，去总仓库拿一批（**批量获取，减少锁频率**）。
3. 总仓库也空了，去旁边那个快递员的车上偷一半包裹过来送（**工作窃取，负载均衡**）。

**一句话总结：GMP 通过引入 P，巧妙地将“全局锁竞争”转化为“本地无锁操作”，并通过“工作窃取”榨干了 CPU 的每一分性能。**

┌─────────────────────────────────────────────────────────────┐
│                        Go Runtime                           │
└─────────────────────────────────────────────────────────────┘

  G (Goroutine)        M (Machine)           P (Processor)
  ┌─────────┐         ┌─────────┐           ┌─────────┐
  │ G1      │         │ M1      │           │ P1      │
  │ ─────── │         │ ─────── │           │ ─────── │
  │ • 栈    │         │ • OS线程│           │ • 本地队列│
  │ • PC    │         │ • 当前G │◄─bindTo──►│ • mcache │
  │ • 状态  │         │ • 当前P │           │ • 当前M  │
  └─────────┘         └─────────┘           └─────────┘
       │                   │                      │
       └───────────────────┴──────────────────────┘
                           │
                    ┌──────┴──────┐
                    │ 全局队列    │
                    │ (Global Q)  │
                    └─────────────┘

G = Goroutine (协程)
M = Machine (OS 线程)
P = Processor (逻辑处理器，默认等于 CPU 核数)
```

### 调度流程

```
              ┌─────────────────────────────────┐
              │         调度循环                │
              └─────────────────────────────────┘
                            │
                            ▼
              ┌─────────────────────────────────┐
              │  1. 从 P 本地队列获取 G         │
              │     (无锁，高效)                │
              └─────────────────────────────────┘
                            │
                    队列为空？
                            │
              ┌─────────────┴─────────────┐
              ▼                           ▼
    ┌───────────────────┐      ┌───────────────────┐
    │ 2. 从全局队列获取 │      │ 3. 工作窃取       │
    │    (需要加锁)     │      │    (从其他P偷)    │
    └───────────────────┘      └───────────────────┘
              │                           │
              └─────────────┬─────────────┘
                            ▼
              ┌─────────────────────────────────┐
              │  4. 执行 G                      │
              └─────────────────────────────────┘
                            │
                            ▼
              ┌─────────────────────────────────┐
              │  5. G 完成/阻塞/让出            │
              │     返回步骤 1                  │
              └─────────────────────────────────┘
```

### Goroutine 状态

```
        ┌──────────────────────────────────────────────┐
        │                                              │
        ▼                                              │
    ┌───────┐    go func()    ┌──────────┐            │
    │ 创建  │ ───────────────→│  可运行  │            │
    │_Gidle │                 │_Grunnable│            │
    └───────┘                 └──────────┘            │
                                   │                  │
                              被调度执行               │
                                   │                  │
                                   ▼                  │
                              ┌──────────┐            │
                              │  运行中  │            │
                              │_Grunning │            │
                              └──────────┘            │
                               /    |    \            │
                              /     |     \           │
                             ▼      ▼      ▼          │
                    ┌─────────┐ ┌─────┐ ┌──────────┐  │
                    │系统调用 │ │等待 │ │  结束    │  │
                    │_Gsyscall│ │_Gwait│ │_Gdead   │  │
                    └─────────┘ └─────┘ └──────────┘  │
                         │         │                  │
                         └─────────┴──────────────────┘
```

### 抢占式调度

Go 1.14+ 实现了**基于信号的抢占式调度**：

| 版本 | 抢占方式 | 局限性 |
|------|----------|--------|
| Go 1.13- | 协作式（函数调用时检查） | 死循环无法被抢占 |
| Go 1.14+ | 基于信号（SIGURG） | 无，真正的抢占式 |

```go
// Go 1.13 之前，这段代码会阻塞整个 P
func badLoop() {
    for {
        // 没有函数调用，无法被抢占
    }
}

// Go 1.14+ 通过 SIGURG 信号实现抢占
// 即使是纯计算的死循环也能被调度器打断
```

### 调度时机

| 时机 | 说明 |
|------|------|
| **go** | 创建新 goroutine |
| **GC** | STW 和并发标记阶段 |
| **系统调用** | 阻塞时 M 与 P 分离 |
| **channel 操作** | 阻塞的发送/接收 |
| **time.Sleep** | 主动让出 |
| **runtime.Gosched** | 主动让出 |
| **抢占信号** | 运行时间过长 (10ms+) |

### M:N 调度优势
这张图非常直观地展示了 **“重型坦克” (传统线程)** 和 **“轻量级特种兵” (Go 协程)** 之间的区别。

之所以 Go 的模型（右边）能实现“用极少的资源做极多的事”，核心秘密在于：**它把“操作系统该干的累活”，在用户态（软件层面）自己干了。**

我们可以从**空间（内存）**和**时间（CPU）**两个维度来详细解释这种“降维打击”般的效果：

---

### 1. 空间维度：内存占用的巨大差异

这是最直观的“省钱”之道。

* **左边：传统线程 (T)**
* **起步价高：** 操作系统创建一个线程，默认栈大小通常是 **1MB ~ 8MB**（取决于 OS）。
* **死板：** 哪怕你的任务只是打印一行 "Hello World"，它也得占这么多坑位。
* **后果：** 如果你想开 10 万个任务，100,000 * 1MB = **100 GB** 内存。还没开始干活，服务器内存就爆了。


* **右边：Goroutine (G)**
* **起步价低：** Go 创建一个协程，初始栈大小只有 **2KB**。
* **灵活：** 它是动态伸缩的。如果任务变复杂，栈不够用了，它会自动扩容（最大可达 1GB，但很少见）。
* **后果：** 10 万个 G，只需要 100,000 * 2KB ≈ **200 MB** 内存。随便一台笔记本都能跑起来。



> **结论：** 同样的内存，Go 能承载的任务数量是传统模型的 **500 倍**以上。

---

### 2. 时间维度：切换成本（Context Switch）

这是性能提升的关键。并发不仅仅是“创建”，更重要的是“切换”。CPU 就像一个飞速旋转的陀螺，需要在不同任务间反复横跳。

* **左边：线程切换 (内核态操作)**
* **流程繁琐：** 线程是操作系统内核调度的。要切换线程，必须从**用户态**陷入**内核态**。
* **包袱重：** 需要保存所有的 CPU 寄存器（16+个）、浮点数状态 (FPU)、信号掩码等一堆数据。
* **耗时：** 大约需要 **1~2 微秒 (µs)**。
* *注：在 CPU 的世界里，1 微秒相当于人类的“几个小时”。*


* **右边：协程切换 (用户态操作)**
* **流程简单：** G 的切换是 Go 运行时（Runtime）自己代码里控制的，根本**不需要通知操作系统**。
* **轻装上阵：** 只需要保存 **3 个寄存器**（PC 程序计数器、SP 栈指针、DX）以及少量的状态。
* **耗时：** 大约只需要 **200 纳秒 (ns)**。
* *注：200 纳秒相当于人类的“几分钟”。*



> **结论：** Go 的切换速度比操作系统线程快 **10~20 倍**。这意味着 CPU 把更多的时间花在“干活”上，而不是花在“换衣服”（切换上下文）上。

---

### 3. 调度逻辑：M:N 模型的“中间商赚差价”

这就要回到你图中间那个 **P (Processor)** 了。

* **左边 (1:1)：**
* 如果 T1 被阻塞了（比如在读文件、等网络请求），与之绑定的 OS 线程也就彻底歇菜了。操作系统为了不让 CPU 闲着，只能强制切换到 T2，这又带来了昂贵的切换成本。


* **右边 (M:N)：**
* **M (OS 线程)** 就像是一个永不休息的工人。
* **P (逻辑处理器)** 就像一个传送带。
* **G (协程)** 是货物。
* **妙处：** 如果 G1 卡住了（例如网络等待），Go 的调度器会**仅仅把 G1 拿下来放到一边**，让 M 继续处理传送带上的 G2、G3。
* **结果：** 此时底层的 **M (OS 线程) 根本没有发生切换**，它一直在全速运行用户代码。这就是“复用”的精髓。



---

### 总结一张表

| 维度 | 左边：传统线程 (1:1) | 右边：Go 协程 (M:N) | 优势分析 |
| --- | --- | --- | --- |
| **内存占用** | ~1MB (固定) | ~2KB (动态) | **省内存，支持海量并发** |
| **创建销毁** | 系统调用 (慢) | 简单的内存分配 (快) | **启动极快** |
| **切换成本** | 1000ns+ (内核态) | ~200ns (用户态) | **CPU 利用率高** |
| **调度方** | 操作系统 (OS) | Go 运行时 (Runtime) | **更懂代码逻辑，调度更精准** |

**一句话总结：**
Go 的模型之所以强，是因为它**把几万个“轻量级任务”塞进了几个“重量级线程”里跑**，并且通过极其聪明的调度器（P），尽可能避免了操作系统层面的昂贵开销。

**既然聊到了“阻塞”处理，你可能会有疑问：**
如果我的代码里写了个死循环，或者一个 G 真的把 M 彻底卡死了（比如计算密集型任务），其他的 G 还能有机会运行吗？（这就是 Go 的**抢占式调度**要解决的问题）。需要我解释这个吗？
```
传统线程模型 (1:1)           Go 调度模型 (M:N)
┌─────┐ ┌─────┐ ┌─────┐     ┌─────┐ ┌─────┐ ┌─────┐
│Task1│ │Task2│ │Task3│     │ G1  │ │ G2  │ │ G3  │ ... (可能数万个)
└──┬──┘ └──┬──┘ └──┬──┘     └──┬──┘ └──┬──┘ └──┬──┘
   │       │       │           │       │       │
   ▼       ▼       ▼           └───────┼───────┘
┌─────┐ ┌─────┐ ┌─────┐                │
│ T1  │ │ T2  │ │ T3  │            ┌───┴───┐
└──┬──┘ └──┬──┘ └──┬──┘            │   P   │ (逻辑处理器)
   │       │       │               └───┬───┘
   ▼       ▼       ▼                   │
┌─────────────────────┐            ┌───┴───┐
│     OS Kernel       │            │   M   │ (少量 OS 线程)
└─────────────────────┘            └───┬───┘
                                       │
                                       ▼
                               ┌───────────────┐
                               │   OS Kernel   │
                               └───────────────┘

• 左边：每个任务对应一个 OS 线程，资源消耗大
• 右边：大量 G 复用少量 M，高效利用资源
```

### 网络轮询器（Netpoller）

Go 使用 **netpoller** 实现高效的网络 I/O：

```
┌────────────────────────────────────────────────────┐
│                   Goroutine                        │
│                                                    │
│   conn.Read()  ──→  检查是否有数据                 │
│                          │                         │
│                    有数据？                        │
│                     /    \                         │
│                   是      否                       │
│                   /        \                       │
│                  ▼          ▼                      │
│            直接返回    注册到 netpoller            │
│                        并让出 P                    │
│                              │                     │
│                              ▼                     │
│                     ┌──────────────┐               │
│                     │  netpoller   │               │
│                     │  (epoll/     │               │
│                     │   kqueue)    │               │
│                     └──────────────┘               │
│                              │                     │
│                         数据就绪                   │
│                              │                     │
│                              ▼                     │
│                     G 重新变为可运行               │
│                     放入 P 的本地队列              │
└────────────────────────────────────────────────────┘

优势：
• 阻塞的网络 I/O 不会阻塞 OS 线程
• 大量网络连接只需少量线程
• 对程序员透明，写同步代码享受异步性能
```

### 常用调优参数

```go
import "runtime"

// 设置 P 的数量（默认等于 CPU 核数）
runtime.GOMAXPROCS(4)

// 获取当前 goroutine 数量
n := runtime.NumGoroutine()

// 主动让出 CPU
runtime.Gosched()

// 获取调度器信息
runtime.GOMAXPROCS(0)  // 返回当前值
runtime.NumCPU()       // CPU 核数
```

```bash
# 调试调度器
GODEBUG=schedtrace=1000 ./myapp   # 每 1000ms 打印调度信息
GODEBUG=scheddetail=1 ./myapp     # 详细调度信息
```

## 快速开始

```bash
# 初始化模块
go mod init go-learning

为什么要执行这一步？（如果不做会怎样？）
在早期的 Go (GOPATH 时代)，代码必须放在特定的系统目录下才能运行。

现在有了 go mod：

代码可以随便放： 你的项目可以放在桌面、D盘、任何你想放的地方，只要有 go.mod 文件，Go 就能识别它。

依赖版本控制： 以后你引入了第三方库（比如 Gin 框架），go.mod 会自动记录你用了哪个版本的 Gin。这就避免了“我电脑上能跑，你电脑上跑不起来”的尴尬。

如果你熟悉其他语言，可以这样类比：

Node.js (npm): 相当于运行 npm init，生成了 package.json。

Java (Maven): 相当于生成了 pom.xml。

Python (Pipenv): 相当于生成了 Pipfile。

# 运行单个示例
go run 01_variables.go

# 运行测试
go test -v ./...
```

## 学习顺序

建议按照数字序号顺序学习，由浅入深：

### 第一阶段：基础语法

| 序号 | 文件 | 内容概要 |
|------|------|----------|
| 01 | `01_variables.go` | 变量声明（var/短声明）、常量、iota、零值、作用域 |
| 02 | `02_types.go` | 整数、浮点、复数、布尔、字符串、类型转换、类型别名 |
| 03 | `03_functions.go` | 函数定义、多返回值、命名返回值、可变参数、闭包、高阶函数 |
| 04 | `04_control_flow.go` | if/for/switch/defer、panic/recover、goto |

### 第二阶段：核心概念

| 序号 | 文件 | 内容概要 |
|------|------|----------|
| 05 | `05_pointers.go` | 指针基础、new 函数、指针与函数、多级指针、unsafe.Pointer |
| 06 | `06_structs.go` | 结构体定义、方法、构造函数模式、JSON 标签、组合 |
| 07 | `07_interfaces.go` | 接口定义、多态、类型断言、类型 switch、空接口 |
| 08 | `08_slices_maps.go` | 数组、切片操作、append/copy、map 操作、二维切片 |

### 第三阶段：工程实践

| 序号 | 文件 | 内容概要 |
|------|------|----------|
| 09 | `09_packages/` | 包与模块管理、go.mod、导入方式、init 函数 |
| 10 | `10_errors.go` | 错误处理、自定义 error、错误包装、errors.Is/As |
| 11 | `11_generics.go` | 类型参数、类型约束、泛型函数/结构体、泛型切片操作 |

### 第四阶段：并发与标准库

| 序号 | 文件 | 内容概要 |
|------|------|----------|
| 12 | `12_concurrency.go` | goroutine、channel、select、sync 包、context |
| 13 | `13_stdlib.go` | fmt/strings/time/os/io/json/regexp/sort/context/log |
| 14 | `14_builtins.go` | make/new/len/cap/append/copy/delete/close/panic/recover |
| 15 | `15_testing_test.go` | 单元测试、表格驱动、基准测试、模糊测试、覆盖率 |

## 目录结构

```
.
├── README.md
├── go.mod
├── 01_variables.go      # 变量与常量
├── 02_types.go          # 基本数据类型
├── 03_functions.go      # 函数
├── 04_control_flow.go   # 流程控制
├── 05_pointers.go       # 指针
├── 06_structs.go        # 结构体与方法
├── 07_interfaces.go     # 接口与类型断言
├── 08_slices_maps.go    # 切片与映射
├── 09_packages/         # 包与模块管理
│   ├── main.go
│   ├── mathutil/
│   │   └── mathutil.go
│   └── stringutil/
│       └── stringutil.go
├── 10_errors.go         # 错误处理
├── 11_generics.go       # 泛型
├── 12_concurrency.go    # 并发编程
├── 13_stdlib.go         # 常用标准库
├── 14_builtins.go       # 内置函数
└── 15_testing/          # 单元测试
    ├── math.go          # 被测试代码
    └── math_test.go     # 测试代码
```

## 运行示例

```bash
# 运行变量示例
go run 01_variables.go

# 运行类型示例
go run 02_types.go

# 运行函数示例
go run 03_functions.go

# 运行流程控制示例
go run 04_control_flow.go

# 运行指针示例
go run 05_pointers.go

# 运行结构体示例
go run 06_structs.go

# 运行接口示例
go run 07_interfaces.go

# 运行切片映射示例
go run 08_slices_maps.go

# 运行包管理示例（需要先初始化）
cd 09_packages && go mod init example.com/packages && go run main.go

# 运行错误处理示例
go run 10_errors.go

# 运行泛型示例
go run 11_generics.go

# 运行并发示例
go run 12_concurrency.go

# 运行标准库示例
go run 13_stdlib.go

# 运行内置函数示例
go run 14_builtins.go

# 运行单元测试
cd 15_testing && go test -v
```

## 测试命令

```bash
# 进入测试目录
cd 15_testing

# 运行所有测试
go test -v

# 运行特定测试
go test -v -run TestAdd

# 运行基准测试
go test -bench=. -benchmem

# 查看测试覆盖率
go test -cover

# 生成覆盖率报告
go test -coverprofile=coverage.out
go tool cover -html=coverage.out

# 运行模糊测试
go test -fuzz=FuzzReverse -fuzztime=30s

# 检测数据竞争
go test -race
```

## 各文件内容详解

### 01_variables.go - 变量与常量
- `var` 关键字声明
- 短变量声明 `:=`
- 批量声明
- 常量与 `iota`
- 零值
- 变量作用域与遮蔽

### 02_types.go - 基本数据类型
- 整数类型（int8~int64, uint8~uint64）
- 浮点类型（float32, float64）
- 复数类型（complex64, complex128）
- 布尔类型
- 字符串类型与 rune
- 类型转换
- 类型别名与自定义类型

### 03_functions.go - 函数
- 函数定义与调用
- 多返回值
- 命名返回值
- 可变参数 `...`
- 匿名函数
- 闭包
- 高阶函数（map/filter/reduce）
- 递归
- 方法值与方法表达式

### 04_control_flow.go - 流程控制
- if 语句（带初始化）
- for 循环（三种形式）
- for-range 遍历
- switch 语句（表达式/类型）
- fallthrough
- break/continue（带标签）
- defer 语句
- panic 与 recover

### 05_pointers.go - 指针
- 取地址 `&` 与解引用 `*`
- `new` 函数
- 指针与函数参数
- 指针与结构体
- 多级指针
- unsafe.Pointer

### 06_structs.go - 结构体与方法
- 结构体定义与初始化
- 字段访问
- 匿名结构体
- 嵌套与组合
- 方法（值接收者/指针接收者）
- 构造函数模式
- JSON 序列化标签
- 空结构体

### 07_interfaces.go - 接口与类型断言
- 接口定义
- 隐式实现
- 多态
- 类型断言
- 类型 switch
- 空接口 `interface{}`/`any`
- 常用接口（Stringer, sort.Interface）
- 接口组合

### 08_slices_maps.go - 切片与映射
- 数组基础
- 切片创建与操作
- append 与容量扩展
- copy 函数
- 切片删除元素
- map 创建与操作
- map 作为 Set
- 二维切片

### 09_packages/ - 包与模块管理
- 包的组织
- 导出规则（大小写）
- 导入方式
- go.mod 文件
- go mod 命令
- init 函数

### 10_errors.go - 错误处理
- errors.New 与 fmt.Errorf
- 自定义错误类型
- 错误包装 `%w`
- errors.Is 与 errors.As
- errors.Join（多错误）
- 错误处理模式

### 11_generics.go - 泛型
- 类型参数
- 类型约束（any, comparable, cmp.Ordered）
- 自定义约束
- 泛型函数
- 泛型结构体
- 泛型切片操作

### 12_concurrency.go - 并发编程
- goroutine
- channel（缓冲/非缓冲）
- select 语句
- 单向 channel
- sync.WaitGroup
- sync.Mutex/RWMutex
- sync.Once
- sync/atomic
- context

### 13_stdlib.go - 常用标准库
- fmt（格式化 I/O）
- strings（字符串操作）
- strconv（类型转换）
- time（时间处理）
- os（操作系统）
- io（I/O 操作）
- filepath（路径处理）
- encoding/json
- regexp（正则表达式）
- sort（排序）
- context
- log（日志）
- flag（命令行参数）
- net/http（HTTP）
- math/rand（随机数）

### 14_builtins.go - 内置函数
- make（创建 slice/map/chan）
- new（分配内存）
- len/cap（长度/容量）
- append（追加元素）
- copy（复制切片）
- delete（删除 map 键）
- close（关闭 channel）
- panic/recover
- complex/real/imag（复数）
- clear（清空，Go 1.21+）
- min/max（Go 1.21+）

### 15_testing_test.go - 单元测试
- 基本测试
- 表格驱动测试
- 子测试
- 测试辅助函数
- 并行测试
- 示例测试
- 基准测试
- 模糊测试
- 测试覆盖率

## 学习建议

1. **边学边练**：每个示例都可以直接运行，建议修改代码观察结果
2. **理解注释**：代码中的注释解释了每个概念的用法和注意事项
3. **动手实验**：尝试修改示例代码，探索不同的行为
4. **查阅文档**：遇到不明白的地方，查阅 [Go 官方文档](https://go.dev/doc/)
5. **实践项目**：学完基础后，尝试写一个小项目巩固所学

## 参考资源

- [Go 官方文档](https://go.dev/doc/)
- [Go by Example](https://gobyexample.com/)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go 语言规范](https://go.dev/ref/spec)
- [Go 标准库文档](https://pkg.go.dev/std)

## License

MIT
