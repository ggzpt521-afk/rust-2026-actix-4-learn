// ============================================================================
// 14_builtins.go - 内置函数
// ============================================================================
// 运行: go run 14_builtins.go
//
// 【本文件学习目标】
// 1. 掌握 make 和 new 的区别与使用场景
// 2. 理解 len 和 cap 在不同类型上的行为
// 3. 学会使用 append 和 copy 操作切片
// 4. 掌握 delete、close 的正确用法
// 5. 理解 panic 和 recover 的工作机制
// 6. 了解 Go 1.21+ 新增的 clear、min、max 函数
//
// 【Go 内置函数概览】
// Go 内置函数是语言内置的特殊函数，无需导入即可使用
// 它们直接由编译器处理，有些无法用普通函数实现
//
// 【内置函数分类】
// | 类别       | 函数                              | 说明                  |
// |------------|-----------------------------------|-----------------------|
// | 分配       | make, new                         | 创建数据结构          |
// | 长度/容量  | len, cap                          | 获取大小信息          |
// | 切片操作   | append, copy, clear               | 修改切片              |
// | Map 操作   | delete, clear                     | 修改 map              |
// | Channel    | close                             | 关闭 channel          |
// | 错误处理   | panic, recover                    | 异常处理              |
// | 复数       | complex, real, imag               | 复数操作              |
// | 比较       | min, max (Go 1.21+)               | 取最值                |
// | 调试       | print, println                    | 调试输出              |
//
// 【重要】内置函数 vs 标准库函数
// - 内置函数：编译器直接处理，如 make、len
// - 标准库函数：普通函数，需要 import，如 fmt.Println
// ============================================================================

package main

import (
	"fmt"
	"unsafe"
)

func main() {
	fmt.Println("=== Go 内置函数 ===\n")

	// ==================== make ====================
	makeDemo()

	// ==================== new ====================
	newDemo()

	// ==================== len 和 cap ====================
	lenCapDemo()

	// ==================== append ====================
	appendDemo()

	// ==================== copy ====================
	copyDemo()

	// ==================== delete ====================
	deleteDemo()

	// ==================== close ====================
	closeDemo()

	// ==================== panic 和 recover ====================
	panicRecoverDemo()

	// ==================== print 和 println ====================
	printDemo()

	// ==================== complex, real, imag ====================
	complexDemo()

	// ==================== clear (Go 1.21+) ====================
	clearDemo()

	// ==================== min 和 max (Go 1.21+) ====================
	minMaxDemo()
}

// ============================================================================
// 【make 函数】
// ============================================================================
// make 用于创建 slice、map、channel 这三种引用类型
//
// 【语法】
// make([]T, len)        // 切片：长度为 len，容量为 len
// make([]T, len, cap)   // 切片：长度为 len，容量为 cap
// make(map[K]V)         // map：空 map
// make(map[K]V, hint)   // map：预分配 hint 大小
// make(chan T)          // channel：无缓冲
// make(chan T, size)    // channel：缓冲区大小 size
//
// 【为什么需要 make？】
// - slice、map、chan 是引用类型，内部包含指针
// - 需要初始化内部数据结构才能使用
// - var m map[string]int 只是声明，m 是 nil，不能直接用
// - m := make(map[string]int) 才创建了可用的 map
//
// 【make vs 字面量】
// make([]int, 0, 10)   vs   []int{}
// make(map[string]int) vs   map[string]int{}
// make(chan int)       vs   无字面量形式
// ============================================================================
func makeDemo() {
	fmt.Println("--- make 函数 ---")
	fmt.Println("make 用于创建 slice、map、channel")

	// ========================================================================
	// 【创建切片】
	// ========================================================================
	// make([]T, len)      - 长度和容量都是 len
	// make([]T, len, cap) - 长度 len，容量 cap
	//
	// 【len 和 cap 的区别】
	// len: 当前元素数量，可以通过索引访问 [0, len)
	// cap: 底层数组大小，append 超过 cap 时会重新分配
	//
	// 【选择建议】
	// - 知道确切大小：make([]T, n)
	// - 只知道最大大小：make([]T, 0, max)
	// - 不确定大小：make([]T, 0) 或 var s []T
	slice1 := make([]int, 5)     // len=5, cap=5，元素全为 0
	slice2 := make([]int, 3, 10) // len=3, cap=10，可以追加 7 个不扩容

	fmt.Printf("make([]int, 5): %v, len=%d, cap=%d\n", slice1, len(slice1), cap(slice1))
	fmt.Printf("make([]int, 3, 10): %v, len=%d, cap=%d\n", slice2, len(slice2), cap(slice2))

	// ========================================================================
	// 【创建 map】
	// ========================================================================
	// make(map[K]V)       - 创建空 map
	// make(map[K]V, hint) - 创建空 map，预分配 hint 大小的空间
	//
	// 【hint 参数的作用】
	// - hint 是预估的元素数量
	// - 可以减少 map 扩容次数
	// - 不是容量限制，可以继续添加元素
	//
	// 【重要】var m map[string]int 是 nil map
	// - 读取返回零值：m["key"] = 0
	// - 写入会 panic！必须 make 后才能写入
	map1 := make(map[string]int)      // 空 map
	map2 := make(map[string]int, 100) // 预分配 100 个元素的空间

	map1["a"] = 1
	map2["b"] = 2
	fmt.Printf("make(map[string]int): %v\n", map1)
	fmt.Printf("make(map[string]int, 100): len=%d\n", len(map2))

	// ========================================================================
	// 【创建 channel】
	// ========================================================================
	// make(chan T)       - 无缓冲 channel
	// make(chan T, size) - 带缓冲 channel
	//
	// 【无缓冲 vs 带缓冲】
	// 无缓冲：发送和接收必须同时准备好（同步）
	// 带缓冲：发送到缓冲区满才阻塞，接收从空缓冲区才阻塞
	//
	// 【选择建议】
	// 无缓冲：需要同步、握手的场景
	// 带缓冲：解耦生产者和消费者、限流
	ch1 := make(chan int)     // 无缓冲，cap=0
	ch2 := make(chan int, 10) // 缓冲区大小 10

	fmt.Printf("make(chan int): cap=%d\n", cap(ch1))
	fmt.Printf("make(chan int, 10): cap=%d\n", cap(ch2))

	close(ch1) // 不用的 channel 要关闭
	close(ch2)
}

// ============================================================================
// 【new 函数】
// ============================================================================
// new 分配内存，返回指向零值的指针
//
// 【语法】
// ptr := new(T)  // 返回 *T，指向 T 类型的零值
//
// 【new 的行为】
// 1. 分配 sizeof(T) 字节的内存
// 2. 将内存清零（所有位设为 0）
// 3. 返回指向这块内存的指针
//
// 【new vs &T{}】
// new(Person) 等价于 &Person{}
// 都是分配零值并返回指针
//
// 【new vs make 对比】
// | 特性     | new(T)             | make(T, args...)       |
// |----------|--------------------|-----------------------|
// | 返回类型 | *T（指针）         | T（值）               |
// | 适用类型 | 任何类型           | slice、map、chan      |
// | 初始化   | 零值               | 初始化内部结构        |
// | 典型用途 | 基本类型、结构体   | 引用类型              |
// ============================================================================
func newDemo() {
	fmt.Println("\n--- new 函数 ---")
	fmt.Println("new 分配内存并返回指针，值为零值")

	// ========================================================================
	// 【基本类型的 new】
	// ========================================================================
	// new 返回指向零值的指针
	// *intPtr 是 0，*strPtr 是 ""，*boolPtr 是 false
	intPtr := new(int)     // 指向 0
	strPtr := new(string)  // 指向 ""
	boolPtr := new(bool)   // 指向 false

	fmt.Printf("new(int): %p -> %d\n", intPtr, *intPtr)
	fmt.Printf("new(string): %p -> %q\n", strPtr, *strPtr)
	fmt.Printf("new(bool): %p -> %v\n", boolPtr, *boolPtr)

	// ========================================================================
	// 【结构体的 new】
	// ========================================================================
	// new(Person) 等价于 &Person{}
	// 所有字段都是零值
	type Person struct {
		Name string
		Age  int
	}
	personPtr := new(Person) // 等价于 &Person{}
	fmt.Printf("new(Person): %+v\n", *personPtr)

	// ========================================================================
	// 【new vs make 总结】
	// ========================================================================
	fmt.Println("\nnew vs make:")
	fmt.Println("  new(T)  - 分配零值内存，返回 *T")
	fmt.Println("  make(T) - 初始化 slice/map/chan，返回 T")
}

// ============================================================================
// 【len 和 cap 函数】
// ============================================================================
// len 返回长度，cap 返回容量
//
// 【len 适用的类型】
// | 类型          | len 返回值            |
// |---------------|----------------------|
// | string        | 字节数（不是字符数）  |
// | [n]T          | 数组长度 n            |
// | []T           | 切片当前元素数        |
// | map[K]V       | map 中键值对数量      |
// | chan T        | channel 中元素数量    |
// | *[n]T         | 数组指针的长度        |
//
// 【cap 适用的类型】
// | 类型          | cap 返回值            |
// |---------------|----------------------|
// | [n]T          | 数组容量（等于 n）    |
// | []T           | 切片底层数组大小      |
// | chan T        | channel 缓冲区大小    |
// | *[n]T         | 数组指针的容量        |
//
// 【注意】map 没有 cap！因为 map 会自动扩容
// ============================================================================
func lenCapDemo() {
	fmt.Println("\n--- len 和 cap 函数 ---")

	// ========================================================================
	// 【字符串的 len】
	// ========================================================================
	// 【重要】len(string) 返回字节数，不是字符数！
	// UTF-8 编码：ASCII 1 字节，中文 3 字节
	str := "Hello, 世界"
	fmt.Printf("字符串 %q:\n", str)
	fmt.Printf("  len (字节数): %d\n", len(str)) // 7 + 6 = 13 字节
	fmt.Printf("  rune 数: %d\n", len([]rune(str))) // 9 个字符

	// ========================================================================
	// 【数组的 len 和 cap】
	// ========================================================================
	// 数组的 len 和 cap 总是相等的（数组大小固定）
	arr := [5]int{1, 2, 3, 4, 5}
	fmt.Printf("数组 %v: len=%d, cap=%d\n", arr, len(arr), cap(arr))

	// ========================================================================
	// 【切片的 len 和 cap】
	// ========================================================================
	// len: 当前元素数
	// cap: 底层数组从切片起始位置到数组末尾的长度
	slice := make([]int, 3, 10)
	fmt.Printf("切片 %v: len=%d, cap=%d\n", slice, len(slice), cap(slice))

	// ========================================================================
	// 【map 的 len】
	// ========================================================================
	// len(map) 返回键值对数量
	// 【注意】map 没有 cap 函数！
	m := map[string]int{"a": 1, "b": 2, "c": 3}
	fmt.Printf("map %v: len=%d\n", m, len(m))
	// cap(m) // 编译错误！map 没有 cap

	// ========================================================================
	// 【channel 的 len 和 cap】
	// ========================================================================
	// len(ch): 当前缓冲区中的元素数
	// cap(ch): 缓冲区大小
	ch := make(chan int, 5)
	ch <- 1
	ch <- 2
	fmt.Printf("channel: len=%d, cap=%d\n", len(ch), cap(ch))
	close(ch)

	// ========================================================================
	// 【数组指针的 len 和 cap】
	// ========================================================================
	// Go 允许对数组指针使用 len 和 cap
	// 这是 Go 的语法糖
	arrPtr := &[3]int{1, 2, 3}
	fmt.Printf("数组指针: len=%d, cap=%d\n", len(arrPtr), cap(arrPtr))
}

// ============================================================================
// 【append 函数】
// ============================================================================
// append 用于向切片追加元素
//
// 【语法】
// slice = append(slice, elem1, elem2...)  // 追加单个或多个元素
// slice = append(slice, anotherSlice...)  // 追加另一个切片（需要 ...）
//
// 【重要】必须接收返回值！
// append 可能会重新分配底层数组
// 如果不接收返回值，可能丢失数据
//
// 【容量扩展规则（Go 1.18+）】
// - 如果新长度 > 2 * 旧容量：新容量 = 新长度
// - 如果旧容量 < 256：新容量 = 2 * 旧容量
// - 否则：新容量 = 旧容量 + (旧容量 + 768) / 4
// （实际规则还有内存对齐因素）
//
// 【nil 切片可以 append】
// var s []int  // s 是 nil
// s = append(s, 1)  // 完全可以！
// ============================================================================
func appendDemo() {
	fmt.Println("\n--- append 函数 ---")

	// ========================================================================
	// 【基本追加】
	// ========================================================================
	slice := []int{1, 2, 3}
	fmt.Printf("原始切片: %v, cap=%d\n", slice, cap(slice))

	// 追加单个元素
	// 【注意】slice = append(...) 必须赋值！
	slice = append(slice, 4)
	fmt.Printf("追加 4: %v, cap=%d\n", slice, cap(slice))

	// 追加多个元素
	slice = append(slice, 5, 6, 7)
	fmt.Printf("追加 5,6,7: %v, cap=%d\n", slice, cap(slice))

	// ========================================================================
	// 【追加另一个切片】
	// ========================================================================
	// 【重要】必须使用 ... 展开切片！
	// append(slice, other) // 编译错误！
	// append(slice, other...) // 正确！
	other := []int{8, 9, 10}
	slice = append(slice, other...) // ... 展开切片
	fmt.Printf("追加切片: %v, cap=%d\n", slice, cap(slice))

	// ========================================================================
	// 【追加到 nil 切片】
	// ========================================================================
	// nil 切片可以直接 append，无需 make
	// 这是推荐的用法
	var nilSlice []int // nil
	nilSlice = append(nilSlice, 1, 2, 3)
	fmt.Printf("nil 切片追加: %v\n", nilSlice)

	// ========================================================================
	// 【容量扩展演示】
	// ========================================================================
	// 观察容量如何增长
	// 小容量时翻倍，大容量时增长约 25%
	fmt.Println("\n容量扩展演示:")
	s := make([]int, 0)
	prevCap := 0
	for i := 0; i < 20; i++ {
		s = append(s, i)
		if cap(s) != prevCap {
			fmt.Printf("  len=%2d, cap=%2d\n", len(s), cap(s))
			prevCap = cap(s)
		}
	}
}

// ============================================================================
// 【copy 函数】
// ============================================================================
// copy 用于复制切片元素
//
// 【语法】
// n := copy(dst, src)  // 返回实际复制的元素数
//
// 【复制规则】
// - 复制的元素数 = min(len(dst), len(src))
// - dst 必须已经有足够的长度（不是容量！）
// - 返回实际复制的元素数
//
// 【特殊用法】
// copy([]byte, string) - 可以将字符串复制到字节切片
//
// 【重叠复制】
// copy 可以安全地处理源和目标重叠的情况
// ============================================================================
func copyDemo() {
	fmt.Println("\n--- copy 函数 ---")

	// ========================================================================
	// 【基本复制】
	// ========================================================================
	src := []int{1, 2, 3, 4, 5}
	dst := make([]int, len(src)) // dst 必须有足够的长度！

	n := copy(dst, src)
	fmt.Printf("copy(%v, %v): 复制了 %d 个元素\n", dst, src, n)

	// ========================================================================
	// 【dst 较短】
	// ========================================================================
	// 只复制 min(len(dst), len(src)) 个元素
	shortDst := make([]int, 3) // 只有 3 个位置
	n = copy(shortDst, src)    // 只复制 3 个
	fmt.Printf("copy(短切片, src): %v, 复制了 %d 个元素\n", shortDst, n)

	// ========================================================================
	// 【dst 较长】
	// ========================================================================
	// 多余的位置保持零值
	longDst := make([]int, 10)
	n = copy(longDst, src)
	fmt.Printf("copy(长切片, src): %v, 复制了 %d 个元素\n", longDst, n)

	// ========================================================================
	// 【复制字符串到字节切片】
	// ========================================================================
	// 特殊用法：copy([]byte, string)
	// 不需要先转换 []byte(s)
	bytes := make([]byte, 10)
	n = copy(bytes, "Hello")
	fmt.Printf("copy([]byte, string): %v (%s), 复制了 %d 个字节\n", bytes, bytes[:n], n)

	// ========================================================================
	// 【重叠复制】
	// ========================================================================
	// copy 可以安全处理源和目标重叠
	// 内部从前向后或从后向前复制，避免数据损坏
	overlapping := []int{1, 2, 3, 4, 5}
	copy(overlapping[2:], overlapping[:3]) // [1,2,3] 复制到 [2:]
	fmt.Printf("重叠复制: %v\n", overlapping) // [1, 2, 1, 2, 3]
}

// ============================================================================
// 【delete 函数】
// ============================================================================
// delete 用于从 map 中删除键值对
//
// 【语法】
// delete(m, key)
//
// 【特点】
// - 如果 key 不存在，不会 panic，什么都不做
// - 如果 m 是 nil，会 panic！
// - 没有返回值，无法知道是否真的删除了
//
// 【删除不存在的键是安全的】
// delete(m, "not_exist") // OK，不会 panic
// ============================================================================
func deleteDemo() {
	fmt.Println("\n--- delete 函数 ---")
	fmt.Println("delete 用于从 map 中删除键值对")

	m := map[string]int{
		"apple":  1,
		"banana": 2,
		"cherry": 3,
	}
	fmt.Printf("原始 map: %v\n", m)

	// 删除存在的键
	delete(m, "banana")
	fmt.Printf("删除 'banana': %v\n", m)

	// 删除不存在的键（不会 panic）
	// 【安全】这是幂等操作
	delete(m, "notexist")
	fmt.Printf("删除不存在的键: %v (无变化)\n", m)

	// 【注意】对 nil map 使用 delete 会 panic
	// var nilMap map[string]int
	// delete(nilMap, "key") // panic!
}

// ============================================================================
// 【close 函数】
// ============================================================================
// close 用于关闭 channel
//
// 【语法】
// close(ch)
//
// 【关闭后的行为】
// - 不能再发送数据（会 panic）
// - 可以继续接收数据（返回缓冲区中的数据）
// - 缓冲区空后，接收返回零值和 false
// - range 循环会自动结束
//
// 【重要规则】
// 1. 只能关闭一次（重复关闭会 panic）
// 2. 只能由发送方关闭（接收方关闭可能导致发送方 panic）
// 3. 关闭 nil channel 会 panic
//
// 【检查是否关闭】
// v, ok := <-ch
// // ok == false 表示 channel 已关闭且为空
// ============================================================================
func closeDemo() {
	fmt.Println("\n--- close 函数 ---")
	fmt.Println("close 用于关闭 channel")

	ch := make(chan int, 3)
	ch <- 1
	ch <- 2
	ch <- 3

	close(ch) // 关闭 channel
	fmt.Println("channel 已关闭")

	// ========================================================================
	// 【从关闭的 channel 读取】
	// ========================================================================
	// range 会自动在 channel 关闭后结束
	for v := range ch {
		fmt.Printf("读取: %d\n", v)
	}

	// ========================================================================
	// 【检查 channel 是否关闭】
	// ========================================================================
	// 使用 comma ok 模式
	v, ok := <-ch
	fmt.Printf("关闭后读取: v=%d, ok=%v\n", v, ok)
	// v=0（零值），ok=false（已关闭且为空）

	// ========================================================================
	// 【close 注意事项】
	// ========================================================================
	fmt.Println("\nclose 注意事项:")
	fmt.Println("  - 只能关闭一次")          // 重复关闭 panic
	fmt.Println("  - 只能由发送方关闭")      // 接收方不应该关闭
	fmt.Println("  - 关闭后不能发送")        // 发送会 panic
	fmt.Println("  - 关闭后可以继续接收（直到缓冲区空）")
}

// ============================================================================
// 【panic 和 recover 函数】
// ============================================================================
// panic 触发恐慌，recover 捕获恐慌
//
// 【panic 的执行流程】
// 1. 停止当前函数执行
// 2. 执行当前函数的 defer（LIFO 顺序）
// 3. 返回到调用者，重复步骤 1-2
// 4. 到达 goroutine 顶层，程序崩溃
//
// 【recover 的使用规则】
// 1. 必须在 defer 函数中调用
// 2. 只能捕获当前 goroutine 的 panic
// 3. 返回 panic 的值，或 nil（无 panic）
//
// 【何时使用 panic】
// ✓ 程序初始化失败（无法继续）
// ✓ 程序员错误（如数组越界）
// ✓ 不可能发生的情况（断言失败）
// ✗ 不要用于普通错误处理（用 error 返回）
//
// 【何时使用 recover】
// ✓ HTTP 处理器中防止单个请求崩溃整个服务
// ✓ 库代码中防止 panic 逃逸给调用者
// ✓ goroutine 中防止 panic 影响其他 goroutine
// ============================================================================
func panicRecoverDemo() {
	fmt.Println("\n--- panic 和 recover 函数 ---")

	// 正常的 panic 会终止程序
	// panic("something went wrong")

	// ========================================================================
	// 【在当前函数设置 recover】
	// ========================================================================
	// recover 必须在 defer 中调用
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("捕获到 panic: %v\n", r)
		}
	}()

	// ========================================================================
	// 【调用可能 panic 的函数】
	// ========================================================================
	result := safeDiv(10, 2)
	fmt.Printf("safeDiv(10, 2) = %d\n", result)

	result = safeDiv(10, 0) // 这会触发 panic，但被 recover 捕获
	fmt.Printf("safeDiv(10, 0) = %d\n", result)

	fmt.Println("程序继续执行...")

	// ========================================================================
	// 【panic/recover 最佳实践】
	// ========================================================================
	fmt.Println("\npanic/recover 最佳实践:")
	fmt.Println("  - panic 用于不可恢复的错误")
	fmt.Println("  - 库代码应避免 panic")
	fmt.Println("  - recover 仅在 defer 中有效")
	fmt.Println("  - 常用于关闭资源、记录日志")
}

// safeDiv: 演示在函数内部使用 recover
// 【命名返回值】允许在 defer 中修改返回值
func safeDiv(a, b int) (result int) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("  除法错误: %v\n", r)
			result = 0 // 通过命名返回值返回默认值
		}
	}()

	if b == 0 {
		panic("division by zero")
	}
	return a / b
}

// ============================================================================
// 【print 和 println 函数】
// ============================================================================
// 内置的 print/println 用于底层调试
//
// 【特点】
// - 输出到 stderr（不是 stdout）
// - 不保证在所有平台可用
// - 格式简单，不支持 %d 等格式化
// - 不会被 go vet 检查格式错误
//
// 【正式代码应使用 fmt 包】
// fmt.Print, fmt.Println, fmt.Printf
// ============================================================================
func printDemo() {
	fmt.Println("\n--- print 和 println 函数 ---")
	fmt.Println("内置的 print/println 用于调试，输出到 stderr")
	fmt.Println("正式代码应使用 fmt 包")

	// 可以取消注释查看效果
	// print("这是 print")
	// println("这是 println")
}

// ============================================================================
// 【complex, real, imag 函数】
// ============================================================================
// Go 内置复数支持
//
// 【复数类型】
// complex64:  实部和虚部都是 float32
// complex128: 实部和虚部都是 float64
//
// 【创建复数】
// c := complex(r, i)  // 从实部和虚部创建
// c := 3 + 4i         // 字面量形式
//
// 【获取实部和虚部】
// r := real(c)  // 实部
// i := imag(c)  // 虚部
// ============================================================================
func complexDemo() {
	fmt.Println("\n--- complex, real, imag 函数 ---")

	// ========================================================================
	// 【创建复数】
	// ========================================================================
	c1 := complex(3, 4) // complex128
	c2 := 2 + 5i        // 字面量，也是 complex128

	fmt.Printf("complex(3, 4) = %v\n", c1)
	fmt.Printf("2 + 5i = %v\n", c2)

	// ========================================================================
	// 【获取实部和虚部】
	// ========================================================================
	fmt.Printf("real(%v) = %.0f\n", c1, real(c1)) // 实部
	fmt.Printf("imag(%v) = %.0f\n", c1, imag(c1)) // 虚部

	// ========================================================================
	// 【复数运算】
	// ========================================================================
	// 复数支持 +, -, *, / 运算
	sum := c1 + c2
	fmt.Printf("%v + %v = %v\n", c1, c2, sum)
}

// ============================================================================
// 【clear 函数 (Go 1.21+)】
// ============================================================================
// clear 清空 slice 或 map
//
// 【对切片的作用】
// - 将所有元素设为零值
// - 长度不变，容量不变
// - 等价于：for i := range s { s[i] = 零值 }
//
// 【对 map 的作用】
// - 删除所有键值对
// - 等价于：for k := range m { delete(m, k) }
//
// 【为什么引入 clear？】
// - 更简洁、更清晰的语义
// - 可能有性能优化（编译器可以优化）
// ============================================================================
func clearDemo() {
	fmt.Println("\n--- clear 函数 (Go 1.21+) ---")
	fmt.Println("clear 清空 slice 或 map")

	// ========================================================================
	// 【清空切片】
	// ========================================================================
	// 元素设为零值，长度不变
	slice := []int{1, 2, 3, 4, 5}
	fmt.Printf("清空前切片: %v\n", slice)
	clear(slice)
	fmt.Printf("清空后切片: %v\n", slice) // [0 0 0 0 0]

	// ========================================================================
	// 【清空 map】
	// ========================================================================
	// 删除所有键值对
	m := map[string]int{"a": 1, "b": 2}
	fmt.Printf("清空前 map: %v, len=%d\n", m, len(m))
	clear(m)
	fmt.Printf("清空后 map: %v, len=%d\n", m, len(m)) // map[], len=0
}

// ============================================================================
// 【min 和 max 函数 (Go 1.21+)】
// ============================================================================
// min 返回最小值，max 返回最大值
//
// 【特点】
// - 接受任意数量参数（至少 1 个）
// - 支持所有可比较类型（整数、浮点数、字符串）
// - 是泛型函数，编译时确定类型
//
// 【语法】
// min(x)           // 返回 x
// min(x, y)        // 返回较小的
// min(x, y, z...)  // 返回最小的
// max 同理
//
// 【字符串比较】
// 按字典序（lexicographic）比较
// "apple" < "banana" < "cherry"
// ============================================================================
func minMaxDemo() {
	fmt.Println("\n--- min 和 max 函数 (Go 1.21+) ---")

	// ========================================================================
	// 【整数】
	// ========================================================================
	fmt.Printf("min(3, 1, 4, 1, 5) = %d\n", min(3, 1, 4, 1, 5))
	fmt.Printf("max(3, 1, 4, 1, 5) = %d\n", max(3, 1, 4, 1, 5))

	// ========================================================================
	// 【浮点数】
	// ========================================================================
	fmt.Printf("min(3.14, 2.71, 1.41) = %.2f\n", min(3.14, 2.71, 1.41))
	fmt.Printf("max(3.14, 2.71, 1.41) = %.2f\n", max(3.14, 2.71, 1.41))

	// ========================================================================
	// 【字符串】
	// ========================================================================
	// 按字典序比较
	fmt.Printf("min(\"apple\", \"banana\") = %s\n", min("apple", "banana"))
	fmt.Printf("max(\"apple\", \"banana\") = %s\n", max("apple", "banana"))

	// ========================================================================
	// 【Go 内置函数总结】
	// ========================================================================
	fmt.Println("\n=== Go 内置函数总结 ===")
	fmt.Println("分配:")
	fmt.Println("  make(T, args...) - 创建 slice/map/chan")
	fmt.Println("  new(T)           - 分配零值内存，返回指针")
	fmt.Println("\n长度/容量:")
	fmt.Println("  len(v)           - 长度")
	fmt.Println("  cap(v)           - 容量")
	fmt.Println("\n切片操作:")
	fmt.Println("  append(s, v...)  - 追加元素")
	fmt.Println("  copy(dst, src)   - 复制切片")
	fmt.Println("  clear(v)         - 清空 (Go 1.21+)")
	fmt.Println("\nMap 操作:")
	fmt.Println("  delete(m, k)     - 删除键")
	fmt.Println("\nChannel:")
	fmt.Println("  close(ch)        - 关闭 channel")
	fmt.Println("\n错误处理:")
	fmt.Println("  panic(v)         - 触发 panic")
	fmt.Println("  recover()        - 捕获 panic")
	fmt.Println("\n复数:")
	fmt.Println("  complex(r, i)    - 创建复数")
	fmt.Println("  real(c)          - 实部")
	fmt.Println("  imag(c)          - 虚部")
	fmt.Println("\n比较:")
	fmt.Println("  min(x, y...)     - 最小值 (Go 1.21+)")
	fmt.Println("  max(x, y...)     - 最大值 (Go 1.21+)")
	fmt.Println("\n其他:")
	fmt.Println("  print/println    - 调试输出")

	// ========================================================================
	// 【unsafe.Sizeof 演示】
	// ========================================================================
	// 注意：unsafe.Sizeof 不是内置函数，但经常与内置函数一起使用
	// 用于获取类型的大小（字节数）
	fmt.Println("\nunsafe.Sizeof (不是内置函数，但常用):")
	fmt.Printf("  int:     %d 字节\n", unsafe.Sizeof(int(0)))
	fmt.Printf("  int64:   %d 字节\n", unsafe.Sizeof(int64(0)))
	fmt.Printf("  float64: %d 字节\n", unsafe.Sizeof(float64(0)))
	fmt.Printf("  string:  %d 字节\n", unsafe.Sizeof(""))     // string header 大小
	fmt.Printf("  slice:   %d 字节\n", unsafe.Sizeof([]int{})) // slice header 大小
	fmt.Printf("  map:     %d 字节\n", unsafe.Sizeof(map[string]int{})) // map 指针大小
}
