// ============================================================================
// 05_pointers.go - 指针
// ============================================================================
// 运行: go run 05_pointers.go
//
// 【本文件学习目标】
// 1. 理解指针的基本概念和用法
// 2. 掌握取地址运算符 & 和解引用运算符 *
// 3. 理解 new 函数的作用
// 4. 掌握指针与函数参数传递的关系
// 5. 了解 Go 的逃逸分析
// 6. 谨慎使用 unsafe.Pointer
//
// 【Go 指针特点】
// - 支持指针，但不支持指针运算（如 p++）
// - 支持安全地返回局部变量的指针（逃逸分析）
// - 没有悬空指针问题（GC 管理内存）
// - 相比 C/C++，指针使用更安全
// ============================================================================

package main

import (
	"fmt"
	"unsafe"
)

func main() {
	fmt.Println("=== Go 指针 ===\n")

	// ========================================================================
	// 【指针基础】
	// ========================================================================
	// 指针是存储另一个变量内存地址的变量
	//
	// 【两个核心操作符】
	// & : 取地址运算符，获取变量的内存地址
	// * : 解引用运算符，获取指针指向的值
	//
	// 【内存模型】
	// ┌─────────┐         ┌─────────┐
	// │   x     │         │   ptr   │
	// │   42    │ <────── │  0x1234 │  (ptr 存储 x 的地址)
	// │ (0x1234)│         │         │
	// └─────────┘         └─────────┘
	//
	// 【指针类型】
	// *T 表示指向类型 T 的指针
	// *int    : 指向 int 的指针
	// *string : 指向 string 的指针
	// **int   : 指向 *int 的指针（二级指针）
	// ========================================================================
	fmt.Println("--- 指针基础 ---")

	// 声明一个整数变量
	x := 42

	// & 取地址：获取 x 的内存地址
	ptr := &x // ptr 的类型是 *int

	fmt.Printf("x 的值: %d\n", x)             // 42
	fmt.Printf("x 的地址: %p\n", &x)          // 如 0xc000018098
	fmt.Printf("ptr 的值（存储的地址）: %p\n", ptr) // 与 &x 相同
	fmt.Printf("ptr 指向的值（*ptr）: %d\n", *ptr) // 42，通过指针访问值
	fmt.Printf("ptr 的类型: %T\n", ptr)        // *int

	// * 解引用：通过指针修改原变量的值
	*ptr = 100 // 修改 ptr 指向的值，即 x
	fmt.Printf("修改后 x 的值: %d\n", x) // 100

	// ========================================================================
	// 【指针的零值】
	// ========================================================================
	// 指针的零值是 nil，表示不指向任何有效内存
	//
	// 【nil 指针的特点】
	// - 等于 nil
	// - 不能解引用（会 panic）
	// - 可以安全地进行 nil 检查
	//
	// 【最佳实践】
	// 在解引用指针之前，总是检查它是否为 nil
	// ========================================================================
	fmt.Println("\n--- 指针的零值 ---")

	var nilPtr *int              // 声明但不初始化，零值为 nil
	fmt.Printf("nil 指针: %v\n", nilPtr)     // <nil>
	fmt.Printf("是否为 nil: %v\n", nilPtr == nil) // true

	// 危险操作！解引用 nil 指针会导致 panic
	// fmt.Println(*nilPtr) // panic: runtime error: invalid memory address

	// ========================================================================
	// 【new 函数】
	// ========================================================================
	// new(T) 分配类型 T 的零值内存，返回指向它的指针 *T
	//
	// 【语法】
	// ptr := new(Type) // 返回 *Type
	//
	// 【与声明变量的对比】
	// var x T      -> 值类型，在栈上分配
	// x := new(T)  -> 指针类型，可能在堆上分配（取决于逃逸分析）
	//
	// 【何时使用 new】
	// - 需要指针但没有现成的变量
	// - 想要零值初始化的对象指针
	// - 通常 &T{} 更常用（可以同时初始化）
	// ========================================================================
	fmt.Println("\n--- new 函数 ---")

	// new 分配零值内存并返回指针
	intPtr := new(int) // 分配 int 大小的内存，初始化为 0
	fmt.Printf("new(int) 返回: %p, 值: %d\n", intPtr, *intPtr) // 地址, 0

	*intPtr = 50 // 通过指针赋值
	fmt.Printf("赋值后: %d\n", *intPtr) // 50

	// 对比：直接声明 vs new
	var a int     // 值类型，值为 0
	b := new(int) // 指针类型，指向的值为 0
	fmt.Printf("var a int: %d, new(int): %d\n", a, *b)

	// ========================================================================
	// 【指针与函数参数】
	// ========================================================================
	// Go 函数参数都是值传递（Pass by Value）
	//
	// 【值传递 vs 指针传递】
	// - 值传递：复制参数的值，函数内修改不影响原值
	// - 指针传递：复制指针（地址），函数可以通过指针修改原值
	//
	// 【何时使用指针参数】
	// 1. 需要修改调用者的变量
	// 2. 避免大结构体的复制开销
	// 3. 需要区分"未设置"和"零值"
	//
	// 【注意】
	// - 切片、map、channel 本身就包含指针，通常不需要传指针
	// - 过度使用指针会增加 GC 压力
	// ========================================================================
	fmt.Println("\n--- 指针与函数 ---")

	// 值传递示例
	num := 10
	fmt.Printf("原始值: %d\n", num)
	doubleValue(num) // 传递值的副本
	fmt.Printf("值传递后: %d (未改变)\n", num) // 仍然是 10

	// 指针传递示例
	doublePointer(&num) // 传递地址
	fmt.Printf("指针传递后: %d (已改变)\n", num) // 变成 20

	// ========================================================================
	// 【返回局部变量的指针】
	// ========================================================================
	// 在 Go 中，可以安全地返回局部变量的指针
	//
	// 【原理：逃逸分析（Escape Analysis）】
	// - 编译器分析变量的生命周期
	// - 如果变量的地址会"逃逸"出函数，就在堆上分配
	// - 如果变量只在函数内使用，就在栈上分配
	//
	// 【查看逃逸分析】
	// go build -gcflags="-m" 可以查看逃逸分析结果
	//
	// 【与 C 的对比】
	// C 语言中返回局部变量的指针是危险的（悬空指针）
	// Go 通过逃逸分析避免了这个问题
	// ========================================================================
	fmt.Println("\n--- 返回局部变量的指针 ---")

	// 安全！createPointer 返回局部变量 local 的指针
	// local 会被分配到堆上，函数返回后仍然有效
	p := createPointer()
	fmt.Printf("返回的指针指向的值: %d\n", *p) // 42

	// ========================================================================
	// 【指针数组 vs 数组指针】
	// ========================================================================
	// 这两个概念容易混淆，需要区分清楚
	//
	// 【指针数组】[n]*T
	// - 数组的元素是指针
	// - 例如 [3]*int 是包含 3 个 *int 的数组
	//
	// 【数组指针】*[n]T
	// - 指向数组的指针
	// - 例如 *[3]int 是指向 [3]int 数组的指针
	// ========================================================================
	fmt.Println("\n--- 指针数组 vs 数组指针 ---")

	// 指针数组：数组中的元素是指针
	a1, a2, a3 := 1, 2, 3
	ptrArray := [3]*int{&a1, &a2, &a3} // 包含 3 个 *int 的数组
	fmt.Printf("指针数组: %v\n", ptrArray)
	for i, p := range ptrArray {
		fmt.Printf("  ptrArray[%d] -> %d\n", i, *p) // 解引用获取值
	}

	// 数组指针：指向数组的指针
	arr := [3]int{10, 20, 30}
	arrPtr := &arr // *[3]int 类型
	fmt.Printf("数组指针: %p\n", arrPtr)
	fmt.Printf("通过指针访问: %v\n", *arrPtr)
	fmt.Printf("通过指针访问元素: %d\n", arrPtr[1]) // Go 语法糖：等价于 (*arrPtr)[1]

	// ========================================================================
	// 【指针与结构体】
	// ========================================================================
	// 结构体指针是最常用的指针类型之一
	//
	// 【语法糖】
	// Go 允许通过指针直接访问结构体字段，无需显式解引用
	// ptr.Field 等价于 (*ptr).Field
	//
	// 【何时使用结构体指针】
	// 1. 需要修改结构体字段
	// 2. 结构体较大，避免复制
	// 3. 方法需要修改接收者
	// ========================================================================
	fmt.Println("\n--- 指针与结构体 ---")

	// 定义一个简单的结构体
	type Person struct {
		Name string
		Age  int
	}

	// 创建结构体实例
	person := Person{Name: "Alice", Age: 25}
	fmt.Printf("原始: %+v\n", person)

	// 获取结构体指针
	personPtr := &person

	// 通过指针访问字段（自动解引用）
	fmt.Printf("通过指针访问: %s, %d\n", personPtr.Name, personPtr.Age)
	// 等价于 (*personPtr).Name，但 Go 允许简写

	// 通过指针修改字段
	personPtr.Age = 26
	fmt.Printf("修改后: %+v\n", person) // person 的 Age 变成 26

	// 使用 new 创建结构体指针
	newPerson := new(Person) // 返回 *Person，字段为零值
	newPerson.Name = "Bob"
	newPerson.Age = 30
	fmt.Printf("new 创建: %+v\n", *newPerson)

	// ========================================================================
	// 【指针与切片】
	// ========================================================================
	// 切片本身是引用类型，底层包含指向数组的指针
	//
	// 【切片的内部结构】
	// type slice struct {
	//     array unsafe.Pointer // 指向底层数组
	//     len   int           // 长度
	//     cap   int           // 容量
	// }
	//
	// 【传递切片】
	// - 传递切片会复制切片头（3 个字段）
	// - 底层数组是共享的
	// - 修改切片元素会影响原切片
	// - 但 append 可能创建新的底层数组
	// ========================================================================
	fmt.Println("\n--- 指针与切片 ---")

	// 切片本身就是引用类型
	slice := []int{1, 2, 3}
	modifySlice(slice) // 修改切片元素
	fmt.Printf("修改切片元素后: %v\n", slice) // [999, 2, 3]

	// append 需要返回新切片（可能重新分配）
	slice = appendToSlice(slice, 4)
	fmt.Printf("append 后: %v\n", slice) // [999, 2, 3, 4]

	// ========================================================================
	// 【指针与 map】
	// ========================================================================
	// map 也是引用类型，传递 map 不会复制数据
	//
	// 【map 的内部结构】
	// map 变量实际上是指向 hmap 结构的指针
	// 所以传递 map 就是传递指针，函数内修改会影响原 map
	// ========================================================================
	fmt.Println("\n--- 指针与 map ---")

	m := map[string]int{"a": 1, "b": 2}
	modifyMap(m) // 修改 map
	fmt.Printf("修改 map 后: %v\n", m) // map[a:1 b:2 c:3]

	// ========================================================================
	// 【多级指针】
	// ========================================================================
	// 指针可以指向另一个指针，形成多级指针
	//
	// 【类型表示】
	// *T   : 一级指针，指向 T
	// **T  : 二级指针，指向 *T
	// ***T : 三级指针，指向 **T
	//
	// 【应用场景】
	// - 在函数中修改指针变量本身
	// - 复杂数据结构（如链表的链表）
	// - 与 C 代码交互
	//
	// 【注意】
	// 多级指针会增加代码复杂度，应谨慎使用
	// ========================================================================
	fmt.Println("\n--- 多级指针 ---")

	val := 100
	ptr1 := &val  // *int，指向 val
	ptr2 := &ptr1 // **int，指向 ptr1
	ptr3 := &ptr2 // ***int，指向 ptr2

	fmt.Printf("val: %d\n", val)        // 100
	fmt.Printf("*ptr1: %d\n", *ptr1)    // 100
	fmt.Printf("**ptr2: %d\n", **ptr2)  // 100
	fmt.Printf("***ptr3: %d\n", ***ptr3) // 100

	// 通过三级指针修改原始值
	***ptr3 = 200
	fmt.Printf("修改后 val: %d\n", val) // 200

	// ========================================================================
	// 【指针比较】
	// ========================================================================
	// 两个指针相等当且仅当它们指向同一个内存地址
	//
	// 【比较规则】
	// - 指向同一变量的指针相等
	// - 指向不同变量的指针不相等（即使值相同）
	// - nil 指针彼此相等
	// - 不同类型的指针不能比较
	// ========================================================================
	fmt.Println("\n--- 指针比较 ---")

	v1, v2 := 42, 42           // 值相同但是不同的变量
	p1, p2 := &v1, &v2         // 指向不同的变量
	p3 := &v1                  // 指向同一个变量 v1

	fmt.Printf("p1 == p2: %v (不同变量的指针)\n", p1 == p2) // false
	fmt.Printf("p1 == p3: %v (同一变量的指针)\n", p1 == p3) // true

	// ========================================================================
	// 【unsafe.Pointer】
	// ========================================================================
	// unsafe.Pointer 可以绕过 Go 的类型系统
	//
	// 【用途】
	// - 与 C 代码交互（CGO）
	// - 底层内存操作
	// - 性能优化（极少数情况）
	//
	// 【警告】
	// - 会绕过 Go 的类型安全检查
	// - 可能导致程序崩溃或安全漏洞
	// - 只在绝对必要时使用
	// - 普通应用开发几乎不需要使用
	// ========================================================================
	fmt.Println("\n--- unsafe.Pointer (谨慎使用) ---")
	unsafePointerDemo()
}

// ============================================================================
// 【值传递示例】
// ============================================================================
// 函数接收参数的副本，修改不影响原变量
// ============================================================================
func doubleValue(n int) {
	n = n * 2 // 只修改了副本
	// 函数返回后，这个修改就丢失了
}

// ============================================================================
// 【指针传递示例】
// ============================================================================
// 函数接收指针，可以通过指针修改原变量
// ============================================================================
func doublePointer(n *int) {
	*n = *n * 2 // 通过指针修改原变量
}

// ============================================================================
// 【返回局部变量指针】
// ============================================================================
// Go 的逃逸分析会将 local 分配到堆上
// 即使函数返回，local 的内存仍然有效
// ============================================================================
func createPointer() *int {
	local := 42   // 这个变量会逃逸到堆上
	return &local // 安全！Go 会正确处理
}

// ============================================================================
// 【修改切片元素】
// ============================================================================
// 切片是引用类型，修改元素会影响原切片
// ============================================================================
func modifySlice(s []int) {
	if len(s) > 0 {
		s[0] = 999 // 修改底层数组的元素
	}
}

// ============================================================================
// 【append 切片】
// ============================================================================
// append 可能创建新的底层数组，所以需要返回新切片
// ============================================================================
func appendToSlice(s []int, val int) []int {
	return append(s, val) // 返回可能重新分配的切片
}

// ============================================================================
// 【修改 map】
// ============================================================================
// map 是引用类型，修改会影响原 map
// ============================================================================
func modifyMap(m map[string]int) {
	m["c"] = 3 // 直接修改原 map
}

// ============================================================================
// 【unsafe.Pointer 演示】
// ============================================================================
// 展示 unsafe.Pointer 的基本用法
// 注意：实际开发中应极少使用
// ============================================================================
func unsafePointerDemo() {
	// unsafe 包可以绕过 Go 的类型系统
	// 仅在必要时使用（如与 C 交互）

	// 获取变量的 unsafe.Pointer
	var i int64 = 42

	// int64 的指针 -> unsafe.Pointer
	// unsafe.Pointer 是通用指针类型，可以转换为任何指针类型
	ptr := unsafe.Pointer(&i)

	fmt.Printf("  原始 int64 值: %d\n", i)
	fmt.Printf("  unsafe.Pointer: %p\n", ptr)
	fmt.Printf("  内存大小: %d 字节\n", unsafe.Sizeof(i)) // 8

	// unsafe.Pointer 的主要用途：
	fmt.Println("  用途: 底层编程、CGO、性能优化")
	fmt.Println("  警告: 绕过类型安全，谨慎使用！")

	// 【unsafe 的合法转换】
	// 1. 任何类型指针 <-> unsafe.Pointer
	// 2. unsafe.Pointer <-> uintptr
	//
	// 【危险操作示例】
	// 以下代码仅作演示，不要在生产代码中使用
	// floatPtr := (*float64)(ptr)  // 将 int64 的内存解释为 float64
}
