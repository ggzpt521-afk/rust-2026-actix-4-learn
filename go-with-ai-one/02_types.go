// ============================================================================
// 02_types.go - 基本数据类型
// ============================================================================
// 运行: go run 02_types.go
//
// 【本文件学习目标】
// 1. 掌握 Go 的整数类型及其范围
// 2. 理解浮点数的精度和特殊值
// 3. 学会处理字符串和 Unicode
// 4. 掌握类型转换的方法
// 5. 理解类型别名与自定义类型的区别
//
// 【Go 类型系统特点】
// - 静态类型：编译时确定类型
// - 强类型：不同类型不能隐式转换
// - 类型安全：编译器检查类型错误
// ============================================================================

package main

import (
	"fmt"     // 格式化 I/O
	"math"    // 数学函数，包含特殊浮点值
	"reflect" // 反射包，用于运行时获取类型信息
	"strconv" // 字符串与其他类型的转换
	"unsafe"  // 不安全操作，用于获取变量大小
)

func main() {
	fmt.Println("=== Go 基本数据类型 ===\n")

	// ========================================================================
	// 【整数类型】
	// ========================================================================
	// Go 提供了丰富的整数类型，分为有符号和无符号两大类
	//
	// 【有符号整数】使用补码表示，可以表示负数
	// | 类型   | 大小   | 范围                                      |
	// |--------|--------|-------------------------------------------|
	// | int8   | 1字节  | -128 到 127                               |
	// | int16  | 2字节  | -32,768 到 32,767                         |
	// | int32  | 4字节  | -2,147,483,648 到 2,147,483,647           |
	// | int64  | 8字节  | -9,223,372,036,854,775,808 到 ...807      |
	// | int    | 平台相关| 32位系统是int32，64位系统是int64          |
	//
	// 【原理】
	// - 补码表示法：最高位是符号位，0表示正，1表示负
	// - 负数 = 取反 + 1
	// - 例如：int8 的 -1 的二进制是 11111111
	//
	// 【注意】
	// - 整数溢出不会报错，会产生回绕（wrap around）
	// - 例如：int8(127) + 1 = -128
	// - 选择合适的类型可以节省内存，但 int 是最常用的
	// ========================================================================
	fmt.Println("--- 整数类型 ---")

	// 有符号整数示例
	var i8 int8 = 127                   // 1字节，范围：-128 到 127
	var i16 int16 = 32767               // 2字节，范围：-32768 到 32767
	var i32 int32 = 2147483647          // 4字节，范围：约 ±21亿
	var i64 int64 = 9223372036854775807 // 8字节，范围：约 ±9.2 * 10^18
	var i int = 42                      // 平台相关：64位系统上是8字节

	// unsafe.Sizeof() 返回变量占用的字节数
	// 这是在编译时计算的，不会影响运行时性能
	fmt.Printf("int8: %d, 大小: %d字节\n", i8, unsafe.Sizeof(i8))
	fmt.Printf("int16: %d, 大小: %d字节\n", i16, unsafe.Sizeof(i16))
	fmt.Printf("int32: %d, 大小: %d字节\n", i32, unsafe.Sizeof(i32))
	fmt.Printf("int64: %d, 大小: %d字节\n", i64, unsafe.Sizeof(i64))
	fmt.Printf("int: %d, 大小: %d字节\n", i, unsafe.Sizeof(i))

	// ========================================================================
	// 【无符号整数】
	// ========================================================================
	// 只能表示非负数，范围是有符号类型的两倍（正数部分）
	//
	// | 类型   | 大小   | 范围                                |
	// |--------|--------|-------------------------------------|
	// | uint8  | 1字节  | 0 到 255                            |
	// | uint16 | 2字节  | 0 到 65,535                         |
	// | uint32 | 4字节  | 0 到 4,294,967,295                  |
	// | uint64 | 8字节  | 0 到 18,446,744,073,709,551,615     |
	// | uint   | 平台相关| 与 int 相同大小                     |
	//
	// 【适用场景】
	// - 数组索引、长度
	// - 颜色值、像素
	// - 需要位运算的场景
	// - 明确不会有负数的计数器
	//
	// 【注意】
	// - uint 减法可能产生回绕：uint(0) - 1 = 最大值
	// - 这是很多 bug 的来源，使用时要小心
	// ========================================================================
	var u8 uint8 = 255                    // 最大值 2^8 - 1
	var u16 uint16 = 65535                // 最大值 2^16 - 1
	var u32 uint32 = 4294967295           // 最大值 2^32 - 1
	var u64 uint64 = 18446744073709551615 // 最大值 2^64 - 1

	fmt.Printf("\nuint8: %d\n", u8)
	fmt.Printf("uint16: %d\n", u16)
	fmt.Printf("uint32: %d\n", u32)
	fmt.Printf("uint64: %d\n", u64)

	// ========================================================================
	// 【特殊整数类型】
	// ========================================================================
	// Go 为常用场景定义了类型别名
	//
	// | 类型    | 实际类型 | 用途                              |
	// |---------|----------|-----------------------------------|
	// | byte    | uint8    | 原始字节数据                       |
	// | rune    | int32    | Unicode 码点（字符）               |
	// | uintptr | uint     | 存储指针值（用于底层编程）          |
	//
	// 【byte vs rune】
	// - byte: 处理 ASCII 字符或原始二进制数据
	// - rune: 处理 Unicode 字符，一个中文字符是一个 rune
	//
	// 【注意】
	// - uintptr 不是指针，只是一个整数，不会被 GC 追踪
	// - 使用 uintptr 保存指针值是不安全的
	// ========================================================================
	var b byte = 'A'         // byte 是 uint8 的别名，存储 ASCII 值
	var r rune = '中'        // rune 是 int32 的别名，存储 Unicode 码点
	var ptr uintptr = 0x1234 // 通常用于底层内存操作

	fmt.Printf("\nbyte('A'): %d, 字符: %c\n", b, b)    // %c 打印字符
	fmt.Printf("rune('中'): %d, 字符: %c\n", r, r)    // Unicode 码点 20013
	fmt.Printf("uintptr: 0x%x\n", ptr)               // %x 十六进制格式

	// ========================================================================
	// 【整数字面量】
	// ========================================================================
	// Go 支持多种进制表示法
	//
	// | 前缀   | 进制   | 示例      |
	// |--------|--------|-----------|
	// | 无     | 十进制 | 42        |
	// | 0b/0B  | 二进制 | 0b101010  |
	// | 0o/0O  | 八进制 | 0o52      |
	// | 0x/0X  | 十六进制| 0x2A      |
	//
	// 【下划线分隔符】（Go 1.13+）
	// - 可以在数字中使用下划线增强可读性
	// - 下划线可以放在任意位置（除了开头和结尾）
	// - 编译器会忽略下划线
	//
	// 【注意】
	// - 旧的八进制写法 052 仍然支持，但推荐使用 0o52
	// - 二进制 0b 前缀是 Go 1.13 新增的
	// ========================================================================
	fmt.Println("\n--- 整数字面量 ---")
	decimal := 42           // 十进制
	binary := 0b101010      // 二进制：1*32 + 0*16 + 1*8 + 0*4 + 1*2 + 0*1 = 42
	octal := 0o52           // 八进制：5*8 + 2*1 = 42
	hex := 0x2A             // 十六进制：2*16 + 10*1 = 42
	withUnderscore := 1_000_000 // 一百万，下划线增强可读性

	fmt.Printf("十进制: %d\n", decimal)
	fmt.Printf("二进制 0b101010: %d\n", binary)
	fmt.Printf("八进制 0o52: %d\n", octal)
	fmt.Printf("十六进制 0x2A: %d\n", hex)
	fmt.Printf("带下划线: %d\n", withUnderscore)

	// ========================================================================
	// 【浮点类型】
	// ========================================================================
	// Go 提供两种浮点类型，遵循 IEEE 754 标准
	//
	// | 类型    | 大小   | 精度              | 范围                    |
	// |---------|--------|-------------------|-------------------------|
	// | float32 | 4字节  | 约 7 位有效数字   | ±1.18e-38 到 ±3.4e38    |
	// | float64 | 8字节  | 约 15 位有效数字  | ±2.23e-308 到 ±1.8e308  |
	//
	// 【原理】IEEE 754 浮点数表示
	// - 符号位(S) + 指数(E) + 尾数(M)
	// - float32: 1 + 8 + 23 = 32 位
	// - float64: 1 + 11 + 52 = 64 位
	// - 值 = (-1)^S × 2^(E-偏移) × (1.M)
	//
	// 【注意】
	// - 浮点数不能精确表示所有十进制小数（如 0.1）
	// - 比较浮点数要使用误差范围，不能直接用 ==
	// - 推荐使用 float64，它是默认的浮点类型
	// - 金融计算不要用浮点数，用整数（分为单位）或 decimal 库
	// ========================================================================
	fmt.Println("\n--- 浮点类型 ---")

	var f32 float32 = 3.14159           // 单精度，约 7 位有效数字
	var f64 float64 = 3.141592653589793 // 双精度，约 15 位有效数字

	fmt.Printf("float32: %.5f, 大小: %d字节\n", f32, unsafe.Sizeof(f32))
	fmt.Printf("float64: %.15f, 大小: %d字节\n", f64, unsafe.Sizeof(f64))

	// ========================================================================
	// 【科学计数法】
	// ========================================================================
	// 使用 e 或 E 表示 10 的幂
	// 6.022e23 = 6.022 × 10^23
	// 6.626e-34 = 6.626 × 10^(-34)
	// ========================================================================
	avogadro := 6.022e23  // 阿伏伽德罗常数：约 6.022 × 10^23
	planck := 6.626e-34   // 普朗克常数：约 6.626 × 10^(-34)
	fmt.Printf("阿伏伽德罗常数: %e\n", avogadro) // %e 科学计数法格式
	fmt.Printf("普朗克常数: %e\n", planck)

	// ========================================================================
	// 【特殊浮点值】
	// ========================================================================
	// IEEE 754 定义了几种特殊值：
	//
	// | 值       | 含义                 | 产生方式           |
	// |----------|----------------------|--------------------|
	// | +Inf     | 正无穷               | 正数/0             |
	// | -Inf     | 负无穷               | 负数/0             |
	// | NaN      | 非数字               | 0/0, Inf-Inf 等    |
	//
	// 【NaN 的特殊性质】
	// - NaN != NaN（自己不等于自己！）
	// - 任何与 NaN 的比较都返回 false
	// - 必须使用 math.IsNaN() 检查
	//
	// 【注意】
	// - 检查无穷：math.IsInf(x, sign)
	// - 检查 NaN：math.IsNaN(x)
	// - 整数除以 0 会 panic，浮点数除以 0 返回 Inf
	// ========================================================================
	inf := math.Inf(1)    // 参数 > 0 返回正无穷
	negInf := math.Inf(-1) // 参数 < 0 返回负无穷
	nan := math.NaN()      // Not a Number

	fmt.Printf("正无穷: %f\n", inf)
	fmt.Printf("负无穷: %f\n", negInf)
	fmt.Printf("NaN: %f, IsNaN: %v\n", nan, math.IsNaN(nan))

	// ========================================================================
	// 【复数类型】
	// ========================================================================
	// Go 原生支持复数运算
	//
	// | 类型       | 组成                | 大小   |
	// |------------|---------------------|--------|
	// | complex64  | float32 实部 + 虚部 | 8字节  |
	// | complex128 | float64 实部 + 虚部 | 16字节 |
	//
	// 【创建方式】
	// 1. 字面量：3 + 4i
	// 2. 内置函数：complex(实部, 虚部)
	//
	// 【获取实部虚部】
	// - real(c)：返回实部
	// - imag(c)：返回虚部
	//
	// 【应用场景】
	// - 信号处理
	// - 傅里叶变换
	// - 电气工程计算
	// ========================================================================
	fmt.Println("\n--- 复数类型 ---")

	var c64 complex64 = 3 + 4i        // 字面量方式创建
	var c128 complex128 = complex(5, 12) // 内置函数创建

	fmt.Printf("complex64: %v\n", c64)
	fmt.Printf("complex128: %v\n", c128)
	fmt.Printf("实部: %.0f, 虚部: %.0f\n", real(c128), imag(c128))
	// 计算模长：|z| = √(实部² + 虚部²)
	fmt.Printf("模长: %.2f\n", math.Sqrt(real(c128)*real(c128)+imag(c128)*imag(c128)))

	// ========================================================================
	// 【布尔类型】
	// ========================================================================
	// bool 类型只有两个值：true 和 false
	//
	// 【原理】
	// - 布尔值在内存中占 1 字节（不是 1 位）
	// - 这是为了内存对齐和访问效率
	//
	// 【运算符】
	// - && 逻辑与（短路求值）
	// - || 逻辑或（短路求值）
	// - !  逻辑非
	//
	// 【短路求值】
	// - a && b：如果 a 为 false，不计算 b
	// - a || b：如果 a 为 true，不计算 b
	//
	// 【注意】
	// - Go 不支持隐式类型转换：if 1 { } 是错误的
	// - 必须显式比较：if n != 0 { }
	// - 布尔值不能转换为整数（不像 C 语言）
	// ========================================================================
	fmt.Println("\n--- 布尔类型 ---")

	var isTrue bool = true   // 真
	var isFalse bool = false // 假

	fmt.Printf("true: %v, false: %v\n", isTrue, isFalse)
	fmt.Printf("逻辑与: %v && %v = %v\n", isTrue, isFalse, isTrue && isFalse)
	fmt.Printf("逻辑或: %v || %v = %v\n", isTrue, isFalse, isTrue || isFalse)
	fmt.Printf("逻辑非: !%v = %v\n", isTrue, !isTrue)

	// ========================================================================
	// 【字符串类型】
	// ========================================================================
	// string 是不可变的字节序列
	//
	// 【内部结构】
	// type stringStruct struct {
	//     str unsafe.Pointer  // 指向字节数组
	//     len int             // 字节长度
	// }
	//
	// 【编码】
	// - Go 源码是 UTF-8 编码
	// - 字符串也是 UTF-8 编码的字节序列
	// - 一个中文字符占 3 字节
	//
	// 【两种字符串字面量】
	// 1. 双引号 "..."：支持转义字符（\n, \t, \\ 等）
	// 2. 反引号 `...`：原始字符串，不转义，可跨行
	//
	// 【注意】
	// - 字符串是不可变的，s[0] = 'x' 会报错
	// - len(s) 返回字节数，不是字符数
	// - 要获取字符数，用 len([]rune(s)) 或 utf8.RuneCountInString(s)
	// ========================================================================
	fmt.Println("\n--- 字符串类型 ---")

	str := "Hello, 世界" // 普通字符串，包含 UTF-8 编码的中文
	raw := `这是原始字符串\n不会转义
可以跨行` // 反引号创建原始字符串

	fmt.Printf("普通字符串: %s\n", str)
	fmt.Printf("字符串长度(字节): %d\n", len(str))      // 13 字节（Hello, 占7字节，每个中文3字节）
	fmt.Printf("字符数量(rune): %d\n", len([]rune(str))) // 9 个字符
	fmt.Println("原始字符串:")
	fmt.Println(raw)

	// ========================================================================
	// 【字符串操作】
	// ========================================================================
	// 常见操作及其时间复杂度：
	//
	// | 操作           | 方法                  | 时间复杂度 |
	// |----------------|----------------------|------------|
	// | 长度（字节）   | len(s)               | O(1)       |
	// | 索引访问       | s[i]                 | O(1)       |
	// | 切片           | s[i:j]               | O(1)       |
	// | 拼接           | s1 + s2              | O(n)       |
	// | 遍历（字节）   | for i := range s     | O(n)       |
	// | 遍历（字符）   | for _, r := range s  | O(n)       |
	//
	// 【注意】
	// - s[i] 返回的是 byte，不是 rune
	// - 切片 s[i:j] 是共享底层数组的（与切片类似）
	// - 大量拼接用 strings.Builder，比 + 高效
	// ========================================================================
	fmt.Println("\n--- 字符串操作 ---")
	s := "Go语言"
	fmt.Printf("字符串: %s\n", s)
	// s[0] 访问第一个字节，'G' 的 ASCII 值是 71
	fmt.Printf("索引访问(字节): s[0]=%d ('%c')\n", s[0], s[0])

	// ========================================================================
	// 【字节遍历 vs 字符遍历】
	// ========================================================================
	// 方式1：按字节遍历
	// - 使用传统 for 循环
	// - 每次迭代处理一个字节
	// - 中文会被拆成多个字节
	//
	// 方式2：按字符（rune）遍历
	// - 使用 for...range
	// - 每次迭代处理一个完整的 Unicode 字符
	// - Go 自动处理 UTF-8 解码
	// ========================================================================
	fmt.Print("按字节遍历: ")
	for i := 0; i < len(s); i++ {
		fmt.Printf("%x ", s[i]) // 打印每个字节的十六进制值
	}
	fmt.Println()
	// 输出: 47 6f e8 af ad e8 a8 80
	// "Go" 是 47 6f，"语言" 每个字占 3 字节

	fmt.Print("按rune遍历: ")
	for _, ch := range s { // ch 是 rune 类型
		fmt.Printf("%c ", ch) // 打印每个字符
	}
	fmt.Println()
	// 输出: G o 语 言

	// ========================================================================
	// 【字符串拼接】
	// ========================================================================
	// 方法1：+ 运算符（简单场景）
	// 方法2：fmt.Sprintf（需要格式化）
	// 方法3：strings.Join（拼接切片）
	// 方法4：strings.Builder（大量拼接，性能最好）
	//
	// 【性能对比】
	// + 运算符：每次创建新字符串，O(n²) 复杂度
	// Builder：预分配内存，O(n) 复杂度
	// ========================================================================
	s1, s2 := "Hello", "World"
	concat := s1 + " " + s2 // 创建新字符串
	fmt.Printf("拼接: %s\n", concat)

	// ========================================================================
	// 【类型转换】
	// ========================================================================
	// Go 不支持隐式类型转换，必须显式转换
	//
	// 【语法】
	// 目标类型(值)
	//
	// 【数值类型转换规则】
	// - 大范围 -> 小范围：可能溢出（截断）
	// - 浮点 -> 整数：截断小数部分（不是四舍五入）
	// - 整数 -> 浮点：可能丢失精度（大整数）
	//
	// 【注意】
	// - 转换不会改变原变量的值
	// - 只有相关类型才能转换（不能把 string 转为 int）
	// - 指针类型之间不能直接转换（需要 unsafe）
	// ========================================================================
	fmt.Println("\n--- 类型转换 ---")

	// 数值类型之间的转换
	intVal := 42
	floatVal := float64(intVal) // int -> float64，无损
	int32Val := int32(intVal)   // int -> int32，注意溢出
	fmt.Printf("int -> float64: %d -> %f\n", intVal, floatVal)
	fmt.Printf("int -> int32: %d -> %d\n", intVal, int32Val)

	// 浮点转整数会截断小数部分
	pi := 3.14159
	intPi := int(pi)  // 3.14159 -> 3（不是四舍五入！）
	fmt.Printf("float64 -> int (截断): %.5f -> %d\n", pi, intPi)

	// ========================================================================
	// 【字符串与数值转换】
	// ========================================================================
	// 使用 strconv 包进行转换
	//
	// | 函数         | 作用                    | 示例                        |
	// |--------------|------------------------|----------------------------|
	// | Atoi         | string -> int          | strconv.Atoi("123")        |
	// | Itoa         | int -> string          | strconv.Itoa(123)          |
	// | ParseInt     | string -> int64        | strconv.ParseInt("123", 10, 64) |
	// | ParseFloat   | string -> float64      | strconv.ParseFloat("3.14", 64)  |
	// | ParseBool    | string -> bool         | strconv.ParseBool("true")  |
	// | FormatInt    | int64 -> string        | strconv.FormatInt(123, 10) |
	// | FormatFloat  | float64 -> string      | strconv.FormatFloat(...)   |
	//
	// 【注意】
	// - Parse 系列函数返回 (值, error)，要处理错误
	// - Atoi/Itoa 是 ParseInt/FormatInt 的简化版
	// - 转换失败时，值为零值，error 不为 nil
	// ========================================================================
	numStr := "123"
	num, _ := strconv.Atoi(numStr) // string -> int，忽略错误
	strNum := strconv.Itoa(num)    // int -> string
	fmt.Printf("string -> int: %q -> %d\n", numStr, num)
	fmt.Printf("int -> string: %d -> %q\n", num, strNum)

	// strconv 更多转换
	floatStr := "3.14"
	floatParsed, _ := strconv.ParseFloat(floatStr, 64) // 第二个参数是精度：32或64
	boolStr := "true"
	boolParsed, _ := strconv.ParseBool(boolStr) // 接受 "true"/"false"/"1"/"0" 等
	fmt.Printf("ParseFloat: %q -> %f\n", floatStr, floatParsed)
	fmt.Printf("ParseBool: %q -> %v\n", boolStr, boolParsed)

	// ========================================================================
	// 【类型别名与自定义类型】
	// ========================================================================
	// Go 有两种方式创建新的类型名称：
	//
	// 1. 类型别名（Type Alias）：type NewName = ExistingType
	//    - 只是另一个名字，与原类型完全相同
	//    - 主要用于大型重构时保持兼容性
	//
	// 2. 自定义类型（Type Definition）：type NewName ExistingType
	//    - 创建一个全新的类型
	//    - 与原类型不同，需要显式转换
	//    - 可以为新类型添加方法
	//
	// 【区别】
	// | 特性       | 类型别名 (=)     | 自定义类型      |
	// |------------|------------------|-----------------|
	// | 与原类型   | 完全相同         | 不同类型        |
	// | 类型转换   | 不需要           | 需要显式转换    |
	// | 添加方法   | 不能             | 可以            |
	// | 反射类型名 | 原类型名         | 新类型名        |
	//
	// 【应用场景】
	// - 类型别名：大型代码库的渐进式重构
	// - 自定义类型：增强类型安全性，添加领域语义
	// ========================================================================
	fmt.Println("\n--- 类型别名与自定义类型 ---")

	// 类型别名（Go 1.9+）
	type MyInt = int  // 别名，MyInt 就是 int
	var mi MyInt = 100
	fmt.Printf("类型别名 MyInt: %d, 类型: %T\n", mi, mi)
	// 输出类型是 int，不是 MyInt

	// 自定义类型（新类型）
	type Age int      // 新类型，Age 不是 int
	var age Age = 25
	fmt.Printf("自定义类型 Age: %d, 类型: %T\n", age, age)
	// 输出类型是 main.Age

	// age = intVal  // 错误！类型不匹配
	// age = Age(intVal)  // 正确，显式转换

	// ========================================================================
	// 【反射获取类型信息】
	// ========================================================================
	// reflect 包提供运行时类型信息
	//
	// 【常用函数】
	// - reflect.TypeOf(x)：获取类型信息
	// - reflect.ValueOf(x)：获取值信息
	// - Type.Kind()：获取底层类型种类
	//
	// 【Kind vs Type】
	// - Type：具体类型名（如 main.Age, []int）
	// - Kind：类型种类（如 int, slice, struct）
	//
	// 【注意】
	// - 反射有性能开销，不要滥用
	// - 反射会绕过类型系统，要小心类型安全
	// ========================================================================
	fmt.Println("\n--- 反射获取类型信息 ---")

	// any 是 interface{} 的类型别名（Go 1.18+）
	values := []any{42, 3.14, "hello", true, []int{1, 2, 3}}
	for _, v := range values {
		t := reflect.TypeOf(v) // 获取类型信息
		fmt.Printf("值: %-12v 类型: %-10s Kind: %s\n", v, t, t.Kind())
	}
	// Kind 显示底层类型：int, float64, string, bool, slice
}
