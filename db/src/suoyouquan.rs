
fn suoyouquan() {
    //所有权测试
    // “& = 借来看一眼，所有权仍在原变量；
    //没有 & = 拿走所有权，原变量作废。”
    //“Copy 类型 → 赋值=按位拷贝 → 原变量仍有效 → 不需要 &
    //非 Copy 类型 → 赋值=移动所有权 → 原变量作废 → 只读场景必须用 &”

    //| 步骤        | Copy 类型              | 非 Copy 类型             |
    //| --------- | -------------------- | --------------------- |
    //| **内存布局**  | **值就在栈上**            | **栈上指针 + 堆上数据**       |
    //| **赋值动作**  | **memcpy 栈数据**（1 指令） | **拷贝栈指针 + 原指针设 NULL** |
    //| **原变量命运** | **仍然有效**             | **作废（不能再用）**          |
    //| **编译器检查** | **无 move 语义**        | **move 语义 → 后续使用报错**  |
    // “i32/f64/char/Copy 元组 → 赋值 = 按位拷贝 → 原变量仍然有效；
    // String/Vec/非 Copy → 赋值 = 移动 → 原变量作废。”
    //| 看到类型                                  | 直觉       | 要不要 &    |
    //| ------------------------------------- | -------- | -------- |
    //| **i32/f64/bool/char/数组/元组**           | **小整数类** | **不需要**  |
    //| **String/Vec/HashMap/Box/自定义 struct** | **大对象类** | **必须 &** |
    
    //“小整数类 = Copy = 赋值=拷贝 → 原变量仍有效 → 不需要 &
    //大对象类 = 非 Copy = 赋值=移动 → 原变量作废 → 只读必须 &”

    let a = String::from("asf");   // a 拥有字符串
    let b = a;                     // **移动所有权** → b 拥有字符串，a 作废
    println!("{}", a);          // ❌ 编译错误：use of moved value: `a`
    println!("{}", b);             // ✅ 只有 b 能用
}